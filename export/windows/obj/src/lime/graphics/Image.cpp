// Generated by Haxe 4.0.2
#include <hxcpp.h>

#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_haxe_io_Bytes
#include <haxe/io/Bytes.h>
#endif
#ifndef INCLUDED_haxe_io_Encoding
#include <haxe/io/Encoding.h>
#endif
#ifndef INCLUDED_lime__internal_backend_native_NativeCFFI
#include <lime/_internal/backend/native/NativeCFFI.h>
#endif
#ifndef INCLUDED_lime__internal_format_BMP
#include <lime/_internal/format/BMP.h>
#endif
#ifndef INCLUDED_lime__internal_format_BMPType
#include <lime/_internal/format/BMPType.h>
#endif
#ifndef INCLUDED_lime__internal_format_Base64
#include <lime/_internal/format/Base64.h>
#endif
#ifndef INCLUDED_lime__internal_format_JPEG
#include <lime/_internal/format/JPEG.h>
#endif
#ifndef INCLUDED_lime__internal_format_PNG
#include <lime/_internal/format/PNG.h>
#endif
#ifndef INCLUDED_lime__internal_graphics_ImageCanvasUtil
#include <lime/_internal/graphics/ImageCanvasUtil.h>
#endif
#ifndef INCLUDED_lime__internal_graphics_ImageDataUtil
#include <lime/_internal/graphics/ImageDataUtil.h>
#endif
#ifndef INCLUDED_lime_app_Future
#include <lime/app/Future.h>
#endif
#ifndef INCLUDED_lime_graphics_Image
#include <lime/graphics/Image.h>
#endif
#ifndef INCLUDED_lime_graphics_ImageBuffer
#include <lime/graphics/ImageBuffer.h>
#endif
#ifndef INCLUDED_lime_graphics_ImageChannel
#include <lime/graphics/ImageChannel.h>
#endif
#ifndef INCLUDED_lime_graphics_ImageFileFormat
#include <lime/graphics/ImageFileFormat.h>
#endif
#ifndef INCLUDED_lime_graphics_ImageType
#include <lime/graphics/ImageType.h>
#endif
#ifndef INCLUDED_lime_math_Rectangle
#include <lime/math/Rectangle.h>
#endif
#ifndef INCLUDED_lime_math_Vector2
#include <lime/math/Vector2.h>
#endif
#ifndef INCLUDED_lime_math__ColorMatrix_ColorMatrix_Impl_
#include <lime/math/_ColorMatrix/ColorMatrix_Impl_.h>
#endif
#ifndef INCLUDED_lime_net__HTTPRequest_AbstractHTTPRequest
#include <lime/net/_HTTPRequest/AbstractHTTPRequest.h>
#endif
#ifndef INCLUDED_lime_net__HTTPRequest_Bytes
#include <lime/net/_HTTPRequest_Bytes.h>
#endif
#ifndef INCLUDED_lime_net__HTTPRequest_lime_graphics_Image
#include <lime/net/_HTTPRequest_lime_graphics_Image.h>
#endif
#ifndef INCLUDED_lime_net__IHTTPRequest
#include <lime/net/_IHTTPRequest.h>
#endif
#ifndef INCLUDED_lime_system_CFFI
#include <lime/system/CFFI.h>
#endif
#ifndef INCLUDED_lime_system_Endian
#include <lime/system/Endian.h>
#endif
#ifndef INCLUDED_lime_utils_ArrayBufferView
#include <lime/utils/ArrayBufferView.h>
#endif
#ifndef INCLUDED_lime_utils_BytePointerData
#include <lime/utils/BytePointerData.h>
#endif
#ifndef INCLUDED_lime_utils_TAError
#include <lime/utils/TAError.h>
#endif
#ifndef INCLUDED_openfl__Vector_IVector
#include <openfl/_Vector/IVector.h>
#endif
#ifndef INCLUDED_openfl__Vector_IntVector
#include <openfl/_Vector/IntVector.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_ef8f6e7e24e3b831_221_new,"lime.graphics.Image","new",0x344ae603,"lime.graphics.Image.new","lime/graphics/Image.hx",221,0xc7b862ad)
HX_LOCAL_STACK_FRAME(_hx_pos_ef8f6e7e24e3b831_287_clone,"lime.graphics.Image","clone",0xb88517c0,"lime.graphics.Image.clone","lime/graphics/Image.hx",287,0xc7b862ad)
HX_LOCAL_STACK_FRAME(_hx_pos_ef8f6e7e24e3b831_316_colorTransform,"lime.graphics.Image","colorTransform",0xaf89aec6,"lime.graphics.Image.colorTransform","lime/graphics/Image.hx",316,0xc7b862ad)
HX_LOCAL_STACK_FRAME(_hx_pos_ef8f6e7e24e3b831_349_copyChannel,"lime.graphics.Image","copyChannel",0xc3306e31,"lime.graphics.Image.copyChannel","lime/graphics/Image.hx",349,0xc7b862ad)
HX_LOCAL_STACK_FRAME(_hx_pos_ef8f6e7e24e3b831_408_copyPixels,"lime.graphics.Image","copyPixels",0x19d2897f,"lime.graphics.Image.copyPixels","lime/graphics/Image.hx",408,0xc7b862ad)
HX_LOCAL_STACK_FRAME(_hx_pos_ef8f6e7e24e3b831_508_encode,"lime.graphics.Image","encode",0xa785c453,"lime.graphics.Image.encode","lime/graphics/Image.hx",508,0xc7b862ad)
HX_LOCAL_STACK_FRAME(_hx_pos_ef8f6e7e24e3b831_532_fillRect,"lime.graphics.Image","fillRect",0x2421e0c4,"lime.graphics.Image.fillRect","lime/graphics/Image.hx",532,0xc7b862ad)
HX_LOCAL_STACK_FRAME(_hx_pos_ef8f6e7e24e3b831_577_floodFill,"lime.graphics.Image","floodFill",0x1da9f544,"lime.graphics.Image.floodFill","lime/graphics/Image.hx",577,0xc7b862ad)
HX_LOCAL_STACK_FRAME(_hx_pos_ef8f6e7e24e3b831_735_getColorBoundsRect,"lime.graphics.Image","getColorBoundsRect",0x21db6743,"lime.graphics.Image.getColorBoundsRect","lime/graphics/Image.hx",735,0xc7b862ad)
HX_LOCAL_STACK_FRAME(_hx_pos_ef8f6e7e24e3b831_767_getPixel,"lime.graphics.Image","getPixel",0xd9e3718d,"lime.graphics.Image.getPixel","lime/graphics/Image.hx",767,0xc7b862ad)
HX_LOCAL_STACK_FRAME(_hx_pos_ef8f6e7e24e3b831_809_getPixel32,"lime.graphics.Image","getPixel32",0xaeccdb6c,"lime.graphics.Image.getPixel32","lime/graphics/Image.hx",809,0xc7b862ad)
HX_LOCAL_STACK_FRAME(_hx_pos_ef8f6e7e24e3b831_850_getPixels,"lime.graphics.Image","getPixels",0xcd1fea46,"lime.graphics.Image.getPixels","lime/graphics/Image.hx",850,0xc7b862ad)
HX_LOCAL_STACK_FRAME(_hx_pos_ef8f6e7e24e3b831_1079_merge,"lime.graphics.Image","merge",0x75e8a71b,"lime.graphics.Image.merge","lime/graphics/Image.hx",1079,0xc7b862ad)
HX_LOCAL_STACK_FRAME(_hx_pos_ef8f6e7e24e3b831_1113_resize,"lime.graphics.Image","resize",0xb61d2c31,"lime.graphics.Image.resize","lime/graphics/Image.hx",1113,0xc7b862ad)
HX_LOCAL_STACK_FRAME(_hx_pos_ef8f6e7e24e3b831_1153_scroll,"lime.graphics.Image","scroll",0xf506aa4a,"lime.graphics.Image.scroll","lime/graphics/Image.hx",1153,0xc7b862ad)
HX_LOCAL_STACK_FRAME(_hx_pos_ef8f6e7e24e3b831_1179_setPixel,"lime.graphics.Image","setPixel",0x8840cb01,"lime.graphics.Image.setPixel","lime/graphics/Image.hx",1179,0xc7b862ad)
HX_LOCAL_STACK_FRAME(_hx_pos_ef8f6e7e24e3b831_1216_setPixel32,"lime.graphics.Image","setPixel32",0xb24a79e0,"lime.graphics.Image.setPixel32","lime/graphics/Image.hx",1216,0xc7b862ad)
HX_LOCAL_STACK_FRAME(_hx_pos_ef8f6e7e24e3b831_1253_setPixels,"lime.graphics.Image","setPixels",0xb070d652,"lime.graphics.Image.setPixels","lime/graphics/Image.hx",1253,0xc7b862ad)
HX_LOCAL_STACK_FRAME(_hx_pos_ef8f6e7e24e3b831_1360_threshold,"lime.graphics.Image","threshold",0xf8c3358e,"lime.graphics.Image.threshold","lime/graphics/Image.hx",1360,0xc7b862ad)
HX_LOCAL_STACK_FRAME(_hx_pos_ef8f6e7e24e3b831_1401___clipRect,"lime.graphics.Image","__clipRect",0xd30737f1,"lime.graphics.Image.__clipRect","lime/graphics/Image.hx",1401,0xc7b862ad)
HX_LOCAL_STACK_FRAME(_hx_pos_ef8f6e7e24e3b831_1465___fromBase64,"lime.graphics.Image","__fromBase64",0x71681bb6,"lime.graphics.Image.__fromBase64","lime/graphics/Image.hx",1465,0xc7b862ad)
HX_LOCAL_STACK_FRAME(_hx_pos_ef8f6e7e24e3b831_1473___fromBytes,"lime.graphics.Image","__fromBytes",0x40972c24,"lime.graphics.Image.__fromBytes","lime/graphics/Image.hx",1473,0xc7b862ad)
HX_LOCAL_STACK_FRAME(_hx_pos_ef8f6e7e24e3b831_1530___fromFile,"lime.graphics.Image","__fromFile",0x1c2444e3,"lime.graphics.Image.__fromFile","lime/graphics/Image.hx",1530,0xc7b862ad)
HX_LOCAL_STACK_FRAME(_hx_pos_ef8f6e7e24e3b831_1692___fromImageBuffer,"lime.graphics.Image","__fromImageBuffer",0xe152fb34,"lime.graphics.Image.__fromImageBuffer","lime/graphics/Image.hx",1692,0xc7b862ad)
HX_LOCAL_STACK_FRAME(_hx_pos_ef8f6e7e24e3b831_1744_get_data,"lime.graphics.Image","get_data",0x7986ad30,"lime.graphics.Image.get_data","lime/graphics/Image.hx",1744,0xc7b862ad)
HX_LOCAL_STACK_FRAME(_hx_pos_ef8f6e7e24e3b831_1760_set_data,"lime.graphics.Image","set_data",0x27e406a4,"lime.graphics.Image.set_data","lime/graphics/Image.hx",1760,0xc7b862ad)
HX_LOCAL_STACK_FRAME(_hx_pos_ef8f6e7e24e3b831_1765_get_format,"lime.graphics.Image","get_format",0xc57a33bd,"lime.graphics.Image.get_format","lime/graphics/Image.hx",1765,0xc7b862ad)
HX_LOCAL_STACK_FRAME(_hx_pos_ef8f6e7e24e3b831_1769_set_format,"lime.graphics.Image","set_format",0xc8f7d231,"lime.graphics.Image.set_format","lime/graphics/Image.hx",1769,0xc7b862ad)
HX_LOCAL_STACK_FRAME(_hx_pos_ef8f6e7e24e3b831_1786_get_powerOfTwo,"lime.graphics.Image","get_powerOfTwo",0x62ee1df6,"lime.graphics.Image.get_powerOfTwo","lime/graphics/Image.hx",1786,0xc7b862ad)
HX_LOCAL_STACK_FRAME(_hx_pos_ef8f6e7e24e3b831_1792_set_powerOfTwo,"lime.graphics.Image","set_powerOfTwo",0x830e066a,"lime.graphics.Image.set_powerOfTwo","lime/graphics/Image.hx",1792,0xc7b862ad)
HX_LOCAL_STACK_FRAME(_hx_pos_ef8f6e7e24e3b831_1843_get_premultiplied,"lime.graphics.Image","get_premultiplied",0xc1478990,"lime.graphics.Image.get_premultiplied","lime/graphics/Image.hx",1843,0xc7b862ad)
HX_LOCAL_STACK_FRAME(_hx_pos_ef8f6e7e24e3b831_1847_set_premultiplied,"lime.graphics.Image","set_premultiplied",0xe4b5619c,"lime.graphics.Image.set_premultiplied","lime/graphics/Image.hx",1847,0xc7b862ad)
HX_LOCAL_STACK_FRAME(_hx_pos_ef8f6e7e24e3b831_1884_get_rect,"lime.graphics.Image","get_rect",0x82caa42a,"lime.graphics.Image.get_rect","lime/graphics/Image.hx",1884,0xc7b862ad)
HX_LOCAL_STACK_FRAME(_hx_pos_ef8f6e7e24e3b831_1896_get_src,"lime.graphics.Image","get_src",0x66c2929e,"lime.graphics.Image.get_src","lime/graphics/Image.hx",1896,0xc7b862ad)
HX_LOCAL_STACK_FRAME(_hx_pos_ef8f6e7e24e3b831_1901_set_src,"lime.graphics.Image","set_src",0x59c423aa,"lime.graphics.Image.set_src","lime/graphics/Image.hx",1901,0xc7b862ad)
HX_LOCAL_STACK_FRAME(_hx_pos_ef8f6e7e24e3b831_1905_get_transparent,"lime.graphics.Image","get_transparent",0xe1ee610c,"lime.graphics.Image.get_transparent","lime/graphics/Image.hx",1905,0xc7b862ad)
HX_LOCAL_STACK_FRAME(_hx_pos_ef8f6e7e24e3b831_1911_set_transparent,"lime.graphics.Image","set_transparent",0xddb9de18,"lime.graphics.Image.set_transparent","lime/graphics/Image.hx",1911,0xc7b862ad)
HX_LOCAL_STACK_FRAME(_hx_pos_ef8f6e7e24e3b831_613_fromBase64,"lime.graphics.Image","fromBase64",0x6fd03756,"lime.graphics.Image.fromBase64","lime/graphics/Image.hx",613,0xc7b862ad)
HX_LOCAL_STACK_FRAME(_hx_pos_ef8f6e7e24e3b831_627_fromBitmapData,"lime.graphics.Image","fromBitmapData",0x2e36df00,"lime.graphics.Image.fromBitmapData","lime/graphics/Image.hx",627,0xc7b862ad)
HX_LOCAL_STACK_FRAME(_hx_pos_ef8f6e7e24e3b831_651_fromBytes,"lime.graphics.Image","fromBytes",0x36406484,"lime.graphics.Image.fromBytes","lime/graphics/Image.hx",651,0xc7b862ad)
HX_LOCAL_STACK_FRAME(_hx_pos_ef8f6e7e24e3b831_671_fromCanvas,"lime.graphics.Image","fromCanvas",0xd2ea8e9f,"lime.graphics.Image.fromCanvas","lime/graphics/Image.hx",671,0xc7b862ad)
HX_LOCAL_STACK_FRAME(_hx_pos_ef8f6e7e24e3b831_694_fromFile,"lime.graphics.Image","fromFile",0x58f03883,"lime.graphics.Image.fromFile","lime/graphics/Image.hx",694,0xc7b862ad)
HX_LOCAL_STACK_FRAME(_hx_pos_ef8f6e7e24e3b831_714_fromImageElement,"lime.graphics.Image","fromImageElement",0x196571a8,"lime.graphics.Image.fromImageElement","lime/graphics/Image.hx",714,0xc7b862ad)
HX_LOCAL_STACK_FRAME(_hx_pos_ef8f6e7e24e3b831_917_loadFromBase64,"lime.graphics.Image","loadFromBase64",0x3166e39c,"lime.graphics.Image.loadFromBase64","lime/graphics/Image.hx",917,0xc7b862ad)
HX_LOCAL_STACK_FRAME(_hx_pos_ef8f6e7e24e3b831_996_loadFromBytes,"lime.graphics.Image","loadFromBytes",0xafa862fe,"lime.graphics.Image.loadFromBytes","lime/graphics/Image.hx",996,0xc7b862ad)
HX_LOCAL_STACK_FRAME(_hx_pos_ef8f6e7e24e3b831_940_loadFromBytes,"lime.graphics.Image","loadFromBytes",0xafa862fe,"lime.graphics.Image.loadFromBytes","lime/graphics/Image.hx",940,0xc7b862ad)
HX_LOCAL_STACK_FRAME(_hx_pos_ef8f6e7e24e3b831_1055_loadFromFile,"lime.graphics.Image","loadFromFile",0xfb592749,"lime.graphics.Image.loadFromFile","lime/graphics/Image.hx",1055,0xc7b862ad)
HX_LOCAL_STACK_FRAME(_hx_pos_ef8f6e7e24e3b831_1006_loadFromFile,"lime.graphics.Image","loadFromFile",0xfb592749,"lime.graphics.Image.loadFromFile","lime/graphics/Image.hx",1006,0xc7b862ad)
HX_LOCAL_STACK_FRAME(_hx_pos_ef8f6e7e24e3b831_1710___isGIF,"lime.graphics.Image","__isGIF",0x6ba10e3d,"lime.graphics.Image.__isGIF","lime/graphics/Image.hx",1710,0xc7b862ad)
HX_LOCAL_STACK_FRAME(_hx_pos_ef8f6e7e24e3b831_1718___isJPG,"lime.graphics.Image","__isJPG",0x6ba35b1a,"lime.graphics.Image.__isJPG","lime/graphics/Image.hx",1718,0xc7b862ad)
HX_LOCAL_STACK_FRAME(_hx_pos_ef8f6e7e24e3b831_1728___isPNG,"lime.graphics.Image","__isPNG",0x6ba7e6e2,"lime.graphics.Image.__isPNG","lime/graphics/Image.hx",1728,0xc7b862ad)
HX_LOCAL_STACK_FRAME(_hx_pos_ef8f6e7e24e3b831_1736___isWebP,"lime.graphics.Image","__isWebP",0xcbf428e3,"lime.graphics.Image.__isWebP","lime/graphics/Image.hx",1736,0xc7b862ad)
namespace lime{
namespace graphics{

void Image_obj::__construct( ::lime::graphics::ImageBuffer buffer,hx::Null< int >  __o_offsetX,hx::Null< int >  __o_offsetY,hx::Null< int >  __o_width,hx::Null< int >  __o_height, ::Dynamic color, ::lime::graphics::ImageType type){
            		int offsetX = __o_offsetX.Default(0);
            		int offsetY = __o_offsetY.Default(0);
            		int width = __o_width.Default(-1);
            		int height = __o_height.Default(-1);
            	HX_GC_STACKFRAME(&_hx_pos_ef8f6e7e24e3b831_221_new)
HXLINE( 222)		this->offsetX = offsetX;
HXLINE( 223)		this->offsetY = offsetY;
HXLINE( 224)		this->width = width;
HXLINE( 225)		this->height = height;
HXLINE( 227)		this->version = 0;
HXLINE( 229)		if (hx::IsNull( type )) {
HXLINE( 236)			type = ::lime::graphics::ImageType_obj::DATA_dyn();
            		}
HXLINE( 240)		this->type = type;
HXLINE( 242)		if (hx::IsNull( buffer )) {
HXLINE( 244)			bool _hx_tmp;
HXDLIN( 244)			if ((width > 0)) {
HXLINE( 244)				_hx_tmp = (height > 0);
            			}
            			else {
HXLINE( 244)				_hx_tmp = false;
            			}
HXDLIN( 244)			if (_hx_tmp) {
HXLINE( 246)				switch((int)(this->type->_hx_getIndex())){
            					case (int)0: {
HXLINE( 249)						this->buffer =  ::lime::graphics::ImageBuffer_obj::__alloc( HX_CTX ,null(),width,height,null(),null());
HXLINE( 250)						::lime::_internal::graphics::ImageCanvasUtil_obj::createCanvas(hx::ObjectPtr<OBJ_>(this),width,height);
HXLINE( 252)						bool _hx_tmp1;
HXDLIN( 252)						if (hx::IsNotNull( color )) {
HXLINE( 252)							_hx_tmp1 = hx::IsNotEq( color,0 );
            						}
            						else {
HXLINE( 252)							_hx_tmp1 = false;
            						}
HXDLIN( 252)						if (_hx_tmp1) {
HXLINE( 254)							this->fillRect( ::lime::math::Rectangle_obj::__alloc( HX_CTX ,0,0,width,height),( (int)(color) ),null());
            						}
            					}
            					break;
            					case (int)1: {
HXLINE( 258)						 ::Dynamic elements = ((width * height) * 4);
HXDLIN( 258)						 ::haxe::io::Bytes buffer1 = null();
HXDLIN( 258)						::cpp::VirtualArray array = null();
HXDLIN( 258)						 ::openfl::_Vector::IntVector vector = null();
HXDLIN( 258)						 ::lime::utils::ArrayBufferView view = null();
HXDLIN( 258)						 ::Dynamic len = null();
HXDLIN( 258)						 ::lime::utils::ArrayBufferView this1;
HXDLIN( 258)						if (hx::IsNotNull( elements )) {
HXLINE( 258)							this1 =  ::lime::utils::ArrayBufferView_obj::__alloc( HX_CTX ,elements,4);
            						}
            						else {
HXLINE( 258)							if (hx::IsNotNull( array )) {
HXLINE( 258)								 ::lime::utils::ArrayBufferView _this =  ::lime::utils::ArrayBufferView_obj::__alloc( HX_CTX ,0,4);
HXDLIN( 258)								_this->byteOffset = 0;
HXDLIN( 258)								_this->length = array->get_length();
HXDLIN( 258)								_this->byteLength = (_this->length * _this->bytesPerElement);
HXDLIN( 258)								 ::haxe::io::Bytes this2 = ::haxe::io::Bytes_obj::alloc(_this->byteLength);
HXDLIN( 258)								_this->buffer = this2;
HXDLIN( 258)								_this->copyFromArray(array,null());
HXDLIN( 258)								this1 = _this;
            							}
            							else {
HXLINE( 258)								if (hx::IsNotNull( vector )) {
HXLINE( 258)									 ::lime::utils::ArrayBufferView _this1 =  ::lime::utils::ArrayBufferView_obj::__alloc( HX_CTX ,0,4);
HXDLIN( 258)									::cpp::VirtualArray array1 = ( (::cpp::VirtualArray)(vector->__Field(HX_("__array",79,c6,ed,8f),hx::paccDynamic)) );
HXDLIN( 258)									_this1->byteOffset = 0;
HXDLIN( 258)									_this1->length = array1->get_length();
HXDLIN( 258)									_this1->byteLength = (_this1->length * _this1->bytesPerElement);
HXDLIN( 258)									 ::haxe::io::Bytes this3 = ::haxe::io::Bytes_obj::alloc(_this1->byteLength);
HXDLIN( 258)									_this1->buffer = this3;
HXDLIN( 258)									_this1->copyFromArray(array1,null());
HXDLIN( 258)									this1 = _this1;
            								}
            								else {
HXLINE( 258)									if (hx::IsNotNull( view )) {
HXLINE( 258)										 ::lime::utils::ArrayBufferView _this2 =  ::lime::utils::ArrayBufferView_obj::__alloc( HX_CTX ,0,4);
HXDLIN( 258)										 ::haxe::io::Bytes srcData = view->buffer;
HXDLIN( 258)										int srcLength = view->length;
HXDLIN( 258)										int srcByteOffset = view->byteOffset;
HXDLIN( 258)										int srcElementSize = view->bytesPerElement;
HXDLIN( 258)										int elementSize = _this2->bytesPerElement;
HXDLIN( 258)										if ((view->type == _this2->type)) {
HXLINE( 258)											int srcLength1 = srcData->length;
HXDLIN( 258)											int cloneLength = (srcLength1 - srcByteOffset);
HXDLIN( 258)											 ::haxe::io::Bytes this4 = ::haxe::io::Bytes_obj::alloc(cloneLength);
HXDLIN( 258)											_this2->buffer = this4;
HXDLIN( 258)											_this2->buffer->blit(0,srcData,srcByteOffset,cloneLength);
            										}
            										else {
HXLINE( 258)											HX_STACK_DO_THROW(HX_("unimplemented",09,2f,74,b4));
            										}
HXDLIN( 258)										_this2->byteLength = (_this2->bytesPerElement * srcLength);
HXDLIN( 258)										_this2->byteOffset = 0;
HXDLIN( 258)										_this2->length = srcLength;
HXDLIN( 258)										this1 = _this2;
            									}
            									else {
HXLINE( 258)										if (hx::IsNotNull( buffer1 )) {
HXLINE( 258)											 ::lime::utils::ArrayBufferView _this3 =  ::lime::utils::ArrayBufferView_obj::__alloc( HX_CTX ,0,4);
HXDLIN( 258)											int in_byteOffset = 0;
HXDLIN( 258)											if ((in_byteOffset < 0)) {
HXLINE( 258)												HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            											}
HXDLIN( 258)											if ((hx::Mod(in_byteOffset,_this3->bytesPerElement) != 0)) {
HXLINE( 258)												HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            											}
HXDLIN( 258)											int bufferByteLength = buffer1->length;
HXDLIN( 258)											int elementSize1 = _this3->bytesPerElement;
HXDLIN( 258)											int newByteLength = bufferByteLength;
HXDLIN( 258)											if (hx::IsNull( len )) {
HXLINE( 258)												newByteLength = (bufferByteLength - in_byteOffset);
HXDLIN( 258)												if ((hx::Mod(bufferByteLength,_this3->bytesPerElement) != 0)) {
HXLINE( 258)													HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            												}
HXDLIN( 258)												if ((newByteLength < 0)) {
HXLINE( 258)													HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            												}
            											}
            											else {
HXLINE( 258)												newByteLength = (( (int)(len) ) * _this3->bytesPerElement);
HXDLIN( 258)												int newRange = (in_byteOffset + newByteLength);
HXDLIN( 258)												if ((newRange > bufferByteLength)) {
HXLINE( 258)													HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            												}
            											}
HXDLIN( 258)											_this3->buffer = buffer1;
HXDLIN( 258)											_this3->byteOffset = in_byteOffset;
HXDLIN( 258)											_this3->byteLength = newByteLength;
HXDLIN( 258)											_this3->length = ::Std_obj::_hx_int((( (Float)(newByteLength) ) / ( (Float)(_this3->bytesPerElement) )));
HXDLIN( 258)											this1 = _this3;
            										}
            										else {
HXLINE( 258)											HX_STACK_DO_THROW(HX_("Invalid constructor arguments for UInt8Array",6b,44,d5,85));
            										}
            									}
            								}
            							}
            						}
HXDLIN( 258)						this->buffer =  ::lime::graphics::ImageBuffer_obj::__alloc( HX_CTX ,this1,width,height,null(),null());
HXLINE( 260)						bool _hx_tmp2;
HXDLIN( 260)						if (hx::IsNotNull( color )) {
HXLINE( 260)							_hx_tmp2 = hx::IsNotEq( color,0 );
            						}
            						else {
HXLINE( 260)							_hx_tmp2 = false;
            						}
HXDLIN( 260)						if (_hx_tmp2) {
HXLINE( 262)							this->fillRect( ::lime::math::Rectangle_obj::__alloc( HX_CTX ,0,0,width,height),( (int)(color) ),null());
            						}
            					}
            					break;
            					case (int)2: {
            					}
            					break;
            					default:{
            					}
            				}
            			}
            		}
            		else {
HXLINE( 277)			this->_hx___fromImageBuffer(buffer);
            		}
            	}

Dynamic Image_obj::__CreateEmpty() { return new Image_obj; }

void *Image_obj::_hx_vtable = 0;

Dynamic Image_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< Image_obj > _hx_result = new Image_obj();
	_hx_result->__construct(inArgs[0],inArgs[1],inArgs[2],inArgs[3],inArgs[4],inArgs[5],inArgs[6]);
	return _hx_result;
}

bool Image_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x66ea719b;
}

 ::lime::graphics::Image Image_obj::clone(){
            	HX_GC_STACKFRAME(&_hx_pos_ef8f6e7e24e3b831_287_clone)
HXDLIN( 287)		if (hx::IsNotNull( this->buffer )) {
HXLINE( 300)			 ::lime::graphics::ImageBuffer image = this->buffer->clone();
HXDLIN( 300)			 ::lime::graphics::Image image1 =  ::lime::graphics::Image_obj::__alloc( HX_CTX ,image,this->offsetX,this->offsetY,this->width,this->height,null(),this->type);
HXLINE( 301)			image1->version = this->version;
HXLINE( 302)			return image1;
            		}
            		else {
HXLINE( 306)			return  ::lime::graphics::Image_obj::__alloc( HX_CTX ,null(),this->offsetX,this->offsetY,this->width,this->height,null(),this->type);
            		}
HXLINE( 287)		return null();
            	}


HX_DEFINE_DYNAMIC_FUNC0(Image_obj,clone,return )

void Image_obj::colorTransform( ::lime::math::Rectangle rect, ::lime::utils::ArrayBufferView colorMatrix){
            	HX_STACKFRAME(&_hx_pos_ef8f6e7e24e3b831_316_colorTransform)
HXLINE( 317)		rect = this->_hx___clipRect(rect);
HXLINE( 318)		bool _hx_tmp;
HXDLIN( 318)		if (hx::IsNotNull( this->buffer )) {
HXLINE( 318)			_hx_tmp = hx::IsNull( rect );
            		}
            		else {
HXLINE( 318)			_hx_tmp = true;
            		}
HXDLIN( 318)		if (_hx_tmp) {
HXLINE( 318)			return;
            		}
HXLINE( 320)		switch((int)(this->type->_hx_getIndex())){
            			case (int)0: {
HXLINE( 323)				::lime::_internal::graphics::ImageCanvasUtil_obj::colorTransform(hx::ObjectPtr<OBJ_>(this),rect,colorMatrix);
            			}
            			break;
            			case (int)1: {
HXLINE( 330)				::lime::_internal::graphics::ImageDataUtil_obj::colorTransform(hx::ObjectPtr<OBJ_>(this),rect,colorMatrix);
            			}
            			break;
            			case (int)2: {
HXLINE( 333)				rect->offset(( (Float)(this->offsetX) ),( (Float)(this->offsetY) ));
HXLINE( 334)				 ::Dynamic _hx_tmp1 =  ::Dynamic(this->buffer->_hx___srcBitmapData->__Field(HX_("colorTransform",89,d7,3f,ad),hx::paccDynamic));
HXDLIN( 334)				 ::Dynamic _hx_tmp2 = rect->_hx___toFlashRectangle();
HXDLIN( 334)				_hx_tmp1(_hx_tmp2,::lime::math::_ColorMatrix::ColorMatrix_Impl__obj::_hx___toFlashColorTransform(colorMatrix));
            			}
            			break;
            			default:{
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC2(Image_obj,colorTransform,(void))

void Image_obj::copyChannel( ::lime::graphics::Image sourceImage, ::lime::math::Rectangle sourceRect, ::lime::math::Vector2 destPoint, ::lime::graphics::ImageChannel sourceChannel, ::lime::graphics::ImageChannel destChannel){
            	HX_STACKFRAME(&_hx_pos_ef8f6e7e24e3b831_349_copyChannel)
HXLINE( 350)		sourceRect = this->_hx___clipRect(sourceRect);
HXLINE( 351)		bool _hx_tmp;
HXDLIN( 351)		if (hx::IsNotNull( this->buffer )) {
HXLINE( 351)			_hx_tmp = hx::IsNull( sourceRect );
            		}
            		else {
HXLINE( 351)			_hx_tmp = true;
            		}
HXDLIN( 351)		if (_hx_tmp) {
HXLINE( 351)			return;
            		}
HXLINE( 352)		bool _hx_tmp1;
HXDLIN( 352)		if (hx::IsEq( destChannel,::lime::graphics::ImageChannel_obj::ALPHA_dyn() )) {
HXLINE( 352)			_hx_tmp1 = !(this->get_transparent());
            		}
            		else {
HXLINE( 352)			_hx_tmp1 = false;
            		}
HXDLIN( 352)		if (_hx_tmp1) {
HXLINE( 352)			return;
            		}
HXLINE( 353)		bool _hx_tmp2;
HXDLIN( 353)		if (!((sourceRect->width <= 0))) {
HXLINE( 353)			_hx_tmp2 = (sourceRect->height <= 0);
            		}
            		else {
HXLINE( 353)			_hx_tmp2 = true;
            		}
HXDLIN( 353)		if (_hx_tmp2) {
HXLINE( 353)			return;
            		}
HXLINE( 354)		if (((sourceRect->x + sourceRect->width) > sourceImage->width)) {
HXLINE( 354)			sourceRect->width = (( (Float)(sourceImage->width) ) - sourceRect->x);
            		}
HXLINE( 355)		if (((sourceRect->y + sourceRect->height) > sourceImage->height)) {
HXLINE( 355)			sourceRect->height = (( (Float)(sourceImage->height) ) - sourceRect->y);
            		}
HXLINE( 357)		switch((int)(this->type->_hx_getIndex())){
            			case (int)0: {
HXLINE( 360)				::lime::_internal::graphics::ImageCanvasUtil_obj::copyChannel(hx::ObjectPtr<OBJ_>(this),sourceImage,sourceRect,destPoint,sourceChannel,destChannel);
            			}
            			break;
            			case (int)1: {
HXLINE( 368)				::lime::_internal::graphics::ImageDataUtil_obj::copyChannel(hx::ObjectPtr<OBJ_>(this),sourceImage,sourceRect,destPoint,sourceChannel,destChannel);
            			}
            			break;
            			case (int)2: {
HXLINE( 371)				int srcChannel;
HXDLIN( 371)				switch((int)(sourceChannel->_hx_getIndex())){
            					case (int)0: {
HXLINE( 371)						srcChannel = 1;
            					}
            					break;
            					case (int)1: {
HXLINE( 371)						srcChannel = 2;
            					}
            					break;
            					case (int)2: {
HXLINE( 371)						srcChannel = 4;
            					}
            					break;
            					case (int)3: {
HXLINE( 371)						srcChannel = 8;
            					}
            					break;
            				}
HXLINE( 379)				int dstChannel;
HXDLIN( 379)				switch((int)(destChannel->_hx_getIndex())){
            					case (int)0: {
HXLINE( 379)						dstChannel = 1;
            					}
            					break;
            					case (int)1: {
HXLINE( 379)						dstChannel = 2;
            					}
            					break;
            					case (int)2: {
HXLINE( 379)						dstChannel = 4;
            					}
            					break;
            					case (int)3: {
HXLINE( 379)						dstChannel = 8;
            					}
            					break;
            				}
HXLINE( 387)				sourceRect->offset(( (Float)(sourceImage->offsetX) ),( (Float)(sourceImage->offsetY) ));
HXLINE( 388)				destPoint->offset(( (Float)(this->offsetX) ),( (Float)(this->offsetY) ));
HXLINE( 390)				 ::Dynamic _hx_tmp3 =  ::Dynamic(this->buffer->_hx___srcBitmapData->__Field(HX_("copyChannel",8e,7d,e6,22),hx::paccDynamic));
HXDLIN( 390)				 ::Dynamic _hx_tmp4 = sourceImage->buffer->get_src();
HXDLIN( 390)				 ::Dynamic _hx_tmp5 = sourceRect->_hx___toFlashRectangle();
HXDLIN( 390)				_hx_tmp3(_hx_tmp4,_hx_tmp5,destPoint->_hx___toFlashPoint(),srcChannel,dstChannel);
            			}
            			break;
            			default:{
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC5(Image_obj,copyChannel,(void))

void Image_obj::copyPixels( ::lime::graphics::Image sourceImage, ::lime::math::Rectangle sourceRect, ::lime::math::Vector2 destPoint, ::lime::graphics::Image alphaImage, ::lime::math::Vector2 alphaPoint,hx::Null< bool >  __o_mergeAlpha){
            		bool mergeAlpha = __o_mergeAlpha.Default(false);
            	HX_STACKFRAME(&_hx_pos_ef8f6e7e24e3b831_408_copyPixels)
HXLINE( 409)		bool _hx_tmp;
HXDLIN( 409)		if (hx::IsNotNull( this->buffer )) {
HXLINE( 409)			_hx_tmp = hx::IsNull( sourceImage );
            		}
            		else {
HXLINE( 409)			_hx_tmp = true;
            		}
HXDLIN( 409)		if (_hx_tmp) {
HXLINE( 409)			return;
            		}
HXLINE( 410)		bool _hx_tmp1;
HXDLIN( 410)		if (!((sourceRect->width <= 0))) {
HXLINE( 410)			_hx_tmp1 = (sourceRect->height <= 0);
            		}
            		else {
HXLINE( 410)			_hx_tmp1 = true;
            		}
HXDLIN( 410)		if (_hx_tmp1) {
HXLINE( 410)			return;
            		}
HXLINE( 411)		bool _hx_tmp2;
HXDLIN( 411)		if ((this->width > 0)) {
HXLINE( 411)			_hx_tmp2 = (this->height <= 0);
            		}
            		else {
HXLINE( 411)			_hx_tmp2 = true;
            		}
HXDLIN( 411)		if (_hx_tmp2) {
HXLINE( 411)			return;
            		}
HXLINE( 413)		if (((sourceRect->x + sourceRect->width) > sourceImage->width)) {
HXLINE( 413)			sourceRect->width = (( (Float)(sourceImage->width) ) - sourceRect->x);
            		}
HXLINE( 414)		if (((sourceRect->y + sourceRect->height) > sourceImage->height)) {
HXLINE( 414)			sourceRect->height = (( (Float)(sourceImage->height) ) - sourceRect->y);
            		}
HXLINE( 416)		if ((sourceRect->x < 0)) {
HXLINE( 418)			 ::lime::math::Rectangle sourceRect1 = sourceRect;
HXDLIN( 418)			sourceRect1->width = (sourceRect1->width + sourceRect->x);
HXLINE( 419)			sourceRect->x = ( (Float)(0) );
            		}
HXLINE( 422)		if ((sourceRect->y < 0)) {
HXLINE( 424)			 ::lime::math::Rectangle sourceRect2 = sourceRect;
HXDLIN( 424)			sourceRect2->height = (sourceRect2->height + sourceRect->y);
HXLINE( 425)			sourceRect->y = ( (Float)(0) );
            		}
HXLINE( 428)		if (((destPoint->x + sourceRect->width) > this->width)) {
HXLINE( 428)			sourceRect->width = (( (Float)(this->width) ) - destPoint->x);
            		}
HXLINE( 429)		if (((destPoint->y + sourceRect->height) > this->height)) {
HXLINE( 429)			sourceRect->height = (( (Float)(this->height) ) - destPoint->y);
            		}
HXLINE( 431)		if ((destPoint->x < 0)) {
HXLINE( 433)			 ::lime::math::Rectangle sourceRect3 = sourceRect;
HXDLIN( 433)			sourceRect3->width = (sourceRect3->width + destPoint->x);
HXLINE( 434)			 ::lime::math::Rectangle sourceRect4 = sourceRect;
HXDLIN( 434)			sourceRect4->x = (sourceRect4->x - destPoint->x);
HXLINE( 435)			destPoint->x = ( (Float)(0) );
            		}
HXLINE( 438)		if ((destPoint->y < 0)) {
HXLINE( 440)			 ::lime::math::Rectangle sourceRect5 = sourceRect;
HXDLIN( 440)			sourceRect5->height = (sourceRect5->height + destPoint->y);
HXLINE( 441)			 ::lime::math::Rectangle sourceRect6 = sourceRect;
HXDLIN( 441)			sourceRect6->y = (sourceRect6->y - destPoint->y);
HXLINE( 442)			destPoint->y = ( (Float)(0) );
            		}
HXLINE( 445)		bool _hx_tmp3;
HXDLIN( 445)		bool _hx_tmp4;
HXDLIN( 445)		if (hx::IsEq( sourceImage,hx::ObjectPtr<OBJ_>(this) )) {
HXLINE( 445)			Float destPoint1 = destPoint->x;
HXDLIN( 445)			_hx_tmp4 = (destPoint1 < sourceRect->get_right());
            		}
            		else {
HXLINE( 445)			_hx_tmp4 = false;
            		}
HXDLIN( 445)		if (_hx_tmp4) {
HXLINE( 445)			Float destPoint2 = destPoint->y;
HXDLIN( 445)			_hx_tmp3 = (destPoint2 < sourceRect->get_bottom());
            		}
            		else {
HXLINE( 445)			_hx_tmp3 = false;
            		}
HXDLIN( 445)		if (_hx_tmp3) {
HXLINE( 448)			sourceImage = this->clone();
            		}
HXLINE( 451)		bool _hx_tmp5;
HXDLIN( 451)		if (hx::IsEq( alphaImage,sourceImage )) {
HXLINE( 451)			if (hx::IsNotNull( alphaPoint )) {
HXLINE( 451)				if ((alphaPoint->x == 0)) {
HXLINE( 451)					_hx_tmp5 = (alphaPoint->y == 0);
            				}
            				else {
HXLINE( 451)					_hx_tmp5 = false;
            				}
            			}
            			else {
HXLINE( 451)				_hx_tmp5 = true;
            			}
            		}
            		else {
HXLINE( 451)			_hx_tmp5 = false;
            		}
HXDLIN( 451)		if (_hx_tmp5) {
HXLINE( 453)			alphaImage = null();
HXLINE( 454)			alphaPoint = null();
            		}
HXLINE( 457)		switch((int)(this->type->_hx_getIndex())){
            			case (int)0: {
HXLINE( 460)				if (hx::IsNotNull( alphaImage )) {
HXLINE( 462)					::lime::_internal::graphics::ImageCanvasUtil_obj::convertToData(hx::ObjectPtr<OBJ_>(this),null());
HXLINE( 463)					::lime::_internal::graphics::ImageCanvasUtil_obj::convertToData(sourceImage,null());
HXLINE( 464)					if (hx::IsNotNull( alphaImage )) {
HXLINE( 464)						::lime::_internal::graphics::ImageCanvasUtil_obj::convertToData(alphaImage,null());
            					}
HXLINE( 466)					::lime::_internal::graphics::ImageDataUtil_obj::copyPixels(hx::ObjectPtr<OBJ_>(this),sourceImage,sourceRect,destPoint,alphaImage,alphaPoint,mergeAlpha);
            				}
            				else {
HXLINE( 470)					::lime::_internal::graphics::ImageCanvasUtil_obj::convertToCanvas(hx::ObjectPtr<OBJ_>(this),null());
HXLINE( 471)					::lime::_internal::graphics::ImageCanvasUtil_obj::convertToCanvas(sourceImage,null());
HXLINE( 472)					::lime::_internal::graphics::ImageCanvasUtil_obj::copyPixels(hx::ObjectPtr<OBJ_>(this),sourceImage,sourceRect,destPoint,alphaImage,alphaPoint,mergeAlpha);
            				}
            			}
            			break;
            			case (int)1: {
HXLINE( 482)				::lime::_internal::graphics::ImageDataUtil_obj::copyPixels(hx::ObjectPtr<OBJ_>(this),sourceImage,sourceRect,destPoint,alphaImage,alphaPoint,mergeAlpha);
            			}
            			break;
            			case (int)2: {
HXLINE( 485)				sourceRect->offset(( (Float)(sourceImage->offsetX) ),( (Float)(sourceImage->offsetY) ));
HXLINE( 486)				destPoint->offset(( (Float)(this->offsetX) ),( (Float)(this->offsetY) ));
HXLINE( 488)				bool _hx_tmp6;
HXDLIN( 488)				if (hx::IsNotNull( alphaImage )) {
HXLINE( 488)					_hx_tmp6 = hx::IsNotNull( alphaPoint );
            				}
            				else {
HXLINE( 488)					_hx_tmp6 = false;
            				}
HXDLIN( 488)				if (_hx_tmp6) {
HXLINE( 490)					alphaPoint->offset(( (Float)(alphaImage->offsetX) ),( (Float)(alphaImage->offsetY) ));
            				}
HXLINE( 493)				 ::Dynamic _hx_tmp7 =  ::Dynamic(this->buffer->_hx___srcBitmapData->__Field(HX_("copyPixels",c2,54,6e,42),hx::paccDynamic));
HXDLIN( 493)				 ::Dynamic sourceImage1 = sourceImage->buffer->_hx___srcBitmapData;
HXDLIN( 493)				 ::Dynamic _hx_tmp8 = sourceRect->_hx___toFlashRectangle();
HXDLIN( 493)				 ::Dynamic _hx_tmp9 = destPoint->_hx___toFlashPoint();
HXLINE( 494)				 ::Dynamic _hx_tmp10;
HXDLIN( 494)				if (hx::IsNotNull( alphaImage )) {
HXLINE( 494)					_hx_tmp10 = alphaImage->buffer->get_src();
            				}
            				else {
HXLINE( 494)					_hx_tmp10 = null();
            				}
HXDLIN( 494)				 ::Dynamic _hx_tmp11;
HXDLIN( 494)				if (hx::IsNotNull( alphaPoint )) {
HXLINE( 494)					_hx_tmp11 = alphaPoint->_hx___toFlashPoint();
            				}
            				else {
HXLINE( 494)					_hx_tmp11 = null();
            				}
HXLINE( 493)				_hx_tmp7(sourceImage1,_hx_tmp8,_hx_tmp9,_hx_tmp10,_hx_tmp11,mergeAlpha);
            			}
            			break;
            			default:{
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC6(Image_obj,copyPixels,(void))

 ::haxe::io::Bytes Image_obj::encode( ::lime::graphics::ImageFileFormat format,hx::Null< int >  __o_quality){
            		int quality = __o_quality.Default(90);
            	HX_STACKFRAME(&_hx_pos_ef8f6e7e24e3b831_508_encode)
HXDLIN( 508)		if (hx::IsNull( format )) {
HXLINE( 511)			return ::lime::_internal::format::PNG_obj::encode(hx::ObjectPtr<OBJ_>(this));
            		}
            		else {
HXDLIN( 508)			switch((int)(format->_hx_getIndex())){
            				case (int)0: {
HXLINE( 517)					return ::lime::_internal::format::BMP_obj::encode(hx::ObjectPtr<OBJ_>(this),null());
            				}
            				break;
            				case (int)1: {
HXLINE( 514)					return ::lime::_internal::format::JPEG_obj::encode(hx::ObjectPtr<OBJ_>(this),quality);
            				}
            				break;
            				case (int)2: {
HXLINE( 511)					return ::lime::_internal::format::PNG_obj::encode(hx::ObjectPtr<OBJ_>(this));
            				}
            				break;
            			}
            		}
HXLINE( 508)		return null();
            	}


HX_DEFINE_DYNAMIC_FUNC2(Image_obj,encode,return )

void Image_obj::fillRect( ::lime::math::Rectangle rect,int color, ::Dynamic format){
            	HX_STACKFRAME(&_hx_pos_ef8f6e7e24e3b831_532_fillRect)
HXLINE( 533)		rect = this->_hx___clipRect(rect);
HXLINE( 534)		bool _hx_tmp;
HXDLIN( 534)		if (hx::IsNotNull( this->buffer )) {
HXLINE( 534)			_hx_tmp = hx::IsNull( rect );
            		}
            		else {
HXLINE( 534)			_hx_tmp = true;
            		}
HXDLIN( 534)		if (_hx_tmp) {
HXLINE( 534)			return;
            		}
HXLINE( 536)		switch((int)(this->type->_hx_getIndex())){
            			case (int)0: {
HXLINE( 539)				::lime::_internal::graphics::ImageCanvasUtil_obj::fillRect(hx::ObjectPtr<OBJ_>(this),rect,color,( (int)(format) ));
            			}
            			break;
            			case (int)1: {
HXLINE( 546)				if ((this->buffer->data->length == 0)) {
HXLINE( 546)					return;
            				}
HXLINE( 548)				::lime::_internal::graphics::ImageDataUtil_obj::fillRect(hx::ObjectPtr<OBJ_>(this),rect,color,( (int)(format) ));
            			}
            			break;
            			case (int)2: {
HXLINE( 551)				rect->offset(( (Float)(this->offsetX) ),( (Float)(this->offsetY) ));
HXLINE( 553)				int argb;
HXDLIN( 553)				if (hx::IsNull( format )) {
HXLINE( 557)					int rgba = color;
HXDLIN( 557)					int this1 = 0;
HXDLIN( 557)					int argb1 = this1;
HXDLIN( 557)					argb1 = ((((((rgba & 255) & 255) << 24) | (((hx::UShr(rgba,24) & 255) & 255) << 16)) | (((hx::UShr(rgba,16) & 255) & 255) << 8)) | ((hx::UShr(rgba,8) & 255) & 255));
HXLINE( 553)					argb = argb1;
            				}
            				else {
HXLINE( 553)					 ::Dynamic _hx_switch_0 = format;
            					if (  (_hx_switch_0==1) ){
HXLINE( 553)						argb = color;
HXDLIN( 553)						goto _hx_goto_6;
            					}
            					if (  (_hx_switch_0==2) ){
HXLINE( 556)						int bgra = color;
HXDLIN( 556)						int this2 = 0;
HXDLIN( 556)						int argb2 = this2;
HXDLIN( 556)						argb2 = ((((((bgra & 255) & 255) << 24) | (((hx::UShr(bgra,8) & 255) & 255) << 16)) | (((hx::UShr(bgra,16) & 255) & 255) << 8)) | ((hx::UShr(bgra,24) & 255) & 255));
HXLINE( 553)						argb = argb2;
HXLINE( 556)						goto _hx_goto_6;
            					}
            					/* default */{
HXLINE( 557)						int rgba1 = color;
HXDLIN( 557)						int this3 = 0;
HXDLIN( 557)						int argb3 = this3;
HXDLIN( 557)						argb3 = ((((((rgba1 & 255) & 255) << 24) | (((hx::UShr(rgba1,24) & 255) & 255) << 16)) | (((hx::UShr(rgba1,16) & 255) & 255) << 8)) | ((hx::UShr(rgba1,8) & 255) & 255));
HXLINE( 553)						argb = argb3;
            					}
            					_hx_goto_6:;
            				}
HXLINE( 560)				 ::Dynamic _hx_tmp1 =  ::Dynamic(this->buffer->_hx___srcBitmapData->__Field(HX_("fillRect",47,45,b9,6c),hx::paccDynamic));
HXDLIN( 560)				_hx_tmp1(rect->_hx___toFlashRectangle(),argb);
            			}
            			break;
            			default:{
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC3(Image_obj,fillRect,(void))

void Image_obj::floodFill(int x,int y,int color, ::Dynamic format){
            	HX_STACKFRAME(&_hx_pos_ef8f6e7e24e3b831_577_floodFill)
HXLINE( 578)		if (hx::IsNull( this->buffer )) {
HXLINE( 578)			return;
            		}
HXLINE( 580)		switch((int)(this->type->_hx_getIndex())){
            			case (int)0: {
HXLINE( 583)				::lime::_internal::graphics::ImageCanvasUtil_obj::floodFill(hx::ObjectPtr<OBJ_>(this),x,y,color,( (int)(format) ));
            			}
            			break;
            			case (int)1: {
HXLINE( 590)				::lime::_internal::graphics::ImageDataUtil_obj::floodFill(hx::ObjectPtr<OBJ_>(this),x,y,color,( (int)(format) ));
            			}
            			break;
            			case (int)2: {
HXLINE( 593)				int argb;
HXDLIN( 593)				if (hx::IsNull( format )) {
HXLINE( 597)					int rgba = color;
HXDLIN( 597)					int this1 = 0;
HXDLIN( 597)					int argb1 = this1;
HXDLIN( 597)					argb1 = ((((((rgba & 255) & 255) << 24) | (((hx::UShr(rgba,24) & 255) & 255) << 16)) | (((hx::UShr(rgba,16) & 255) & 255) << 8)) | ((hx::UShr(rgba,8) & 255) & 255));
HXLINE( 593)					argb = argb1;
            				}
            				else {
HXLINE( 593)					 ::Dynamic _hx_switch_0 = format;
            					if (  (_hx_switch_0==1) ){
HXLINE( 593)						argb = color;
HXDLIN( 593)						goto _hx_goto_8;
            					}
            					if (  (_hx_switch_0==2) ){
HXLINE( 596)						int bgra = color;
HXDLIN( 596)						int this2 = 0;
HXDLIN( 596)						int argb2 = this2;
HXDLIN( 596)						argb2 = ((((((bgra & 255) & 255) << 24) | (((hx::UShr(bgra,8) & 255) & 255) << 16)) | (((hx::UShr(bgra,16) & 255) & 255) << 8)) | ((hx::UShr(bgra,24) & 255) & 255));
HXLINE( 593)						argb = argb2;
HXLINE( 596)						goto _hx_goto_8;
            					}
            					/* default */{
HXLINE( 597)						int rgba1 = color;
HXDLIN( 597)						int this3 = 0;
HXDLIN( 597)						int argb3 = this3;
HXDLIN( 597)						argb3 = ((((((rgba1 & 255) & 255) << 24) | (((hx::UShr(rgba1,24) & 255) & 255) << 16)) | (((hx::UShr(rgba1,16) & 255) & 255) << 8)) | ((hx::UShr(rgba1,8) & 255) & 255));
HXLINE( 593)						argb = argb3;
            					}
            					_hx_goto_8:;
            				}
HXLINE( 600)				this->buffer->_hx___srcBitmapData->__Field(HX_("floodFill",61,83,8a,59),hx::paccDynamic)((x + this->offsetX),(y + this->offsetY),argb);
            			}
            			break;
            			default:{
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC4(Image_obj,floodFill,(void))

 ::lime::math::Rectangle Image_obj::getColorBoundsRect(int mask,int color,hx::Null< bool >  __o_findColor, ::Dynamic format){
            		bool findColor = __o_findColor.Default(true);
            	HX_GC_STACKFRAME(&_hx_pos_ef8f6e7e24e3b831_735_getColorBoundsRect)
HXLINE( 736)		if (hx::IsNull( this->buffer )) {
HXLINE( 736)			return null();
            		}
HXLINE( 738)		switch((int)(this->type->_hx_getIndex())){
            			case (int)0: {
HXLINE( 745)				return ::lime::_internal::graphics::ImageDataUtil_obj::getColorBoundsRect(hx::ObjectPtr<OBJ_>(this),mask,color,findColor,( (int)(format) ));
            			}
            			break;
            			case (int)1: {
HXLINE( 748)				return ::lime::_internal::graphics::ImageDataUtil_obj::getColorBoundsRect(hx::ObjectPtr<OBJ_>(this),mask,color,findColor,( (int)(format) ));
            			}
            			break;
            			case (int)2: {
HXLINE( 751)				 ::Dynamic rect = this->buffer->_hx___srcBitmapData->__Field(HX_("getColorBoundsRect",86,ad,e8,80),hx::paccDynamic)(mask,color,findColor);
HXLINE( 752)				return  ::lime::math::Rectangle_obj::__alloc( HX_CTX ,rect->__Field(HX_("x",78,00,00,00),hx::paccDynamic),rect->__Field(HX_("y",79,00,00,00),hx::paccDynamic),rect->__Field(HX_("width",06,b6,62,ca),hx::paccDynamic),rect->__Field(HX_("height",e7,07,4c,02),hx::paccDynamic));
            			}
            			break;
            			default:{
HXLINE( 755)				return null();
            			}
            		}
HXLINE( 738)		return null();
            	}


HX_DEFINE_DYNAMIC_FUNC4(Image_obj,getColorBoundsRect,return )

int Image_obj::getPixel(int x,int y, ::Dynamic format){
            	HX_STACKFRAME(&_hx_pos_ef8f6e7e24e3b831_767_getPixel)
HXLINE( 768)		bool _hx_tmp;
HXDLIN( 768)		bool _hx_tmp1;
HXDLIN( 768)		bool _hx_tmp2;
HXDLIN( 768)		bool _hx_tmp3;
HXDLIN( 768)		if (hx::IsNotNull( this->buffer )) {
HXLINE( 768)			_hx_tmp3 = (x < 0);
            		}
            		else {
HXLINE( 768)			_hx_tmp3 = true;
            		}
HXDLIN( 768)		if (!(_hx_tmp3)) {
HXLINE( 768)			_hx_tmp2 = (y < 0);
            		}
            		else {
HXLINE( 768)			_hx_tmp2 = true;
            		}
HXDLIN( 768)		if (!(_hx_tmp2)) {
HXLINE( 768)			_hx_tmp1 = (x >= this->width);
            		}
            		else {
HXLINE( 768)			_hx_tmp1 = true;
            		}
HXDLIN( 768)		if (!(_hx_tmp1)) {
HXLINE( 768)			_hx_tmp = (y >= this->height);
            		}
            		else {
HXLINE( 768)			_hx_tmp = true;
            		}
HXDLIN( 768)		if (_hx_tmp) {
HXLINE( 768)			return 0;
            		}
HXLINE( 770)		switch((int)(this->type->_hx_getIndex())){
            			case (int)0: {
HXLINE( 773)				return ::lime::_internal::graphics::ImageCanvasUtil_obj::getPixel(hx::ObjectPtr<OBJ_>(this),x,y,( (int)(format) ));
            			}
            			break;
            			case (int)1: {
HXLINE( 780)				return ::lime::_internal::graphics::ImageDataUtil_obj::getPixel(hx::ObjectPtr<OBJ_>(this),x,y,( (int)(format) ));
            			}
            			break;
            			case (int)2: {
HXLINE( 783)				int color = ( (int)(this->buffer->_hx___srcBitmapData->__Field(HX_("getPixel",10,d6,7a,22),hx::paccDynamic)((x + this->offsetX),(y + this->offsetY))) );
HXLINE( 785)				if (hx::IsNull( format )) {
HXLINE( 792)					int this1 = 0;
HXDLIN( 792)					int rgba = this1;
HXDLIN( 792)					rgba = ((((((hx::UShr(color,16) & 255) & 255) << 24) | (((hx::UShr(color,8) & 255) & 255) << 16)) | (((color & 255) & 255) << 8)) | ((hx::UShr(color,24) & 255) & 255));
HXDLIN( 792)					int rgba1 = rgba;
HXLINE( 793)					return rgba1;
            				}
            				else {
HXLINE( 785)					 ::Dynamic _hx_switch_0 = format;
            					if (  (_hx_switch_0==1) ){
HXLINE( 787)						return color;
HXDLIN( 787)						goto _hx_goto_11;
            					}
            					if (  (_hx_switch_0==2) ){
HXLINE( 789)						int this2 = 0;
HXDLIN( 789)						int bgra = this2;
HXDLIN( 789)						bgra = ((((((color & 255) & 255) << 24) | (((hx::UShr(color,8) & 255) & 255) << 16)) | (((hx::UShr(color,16) & 255) & 255) << 8)) | ((hx::UShr(color,24) & 255) & 255));
HXDLIN( 789)						int bgra1 = bgra;
HXLINE( 790)						return bgra1;
HXLINE( 788)						goto _hx_goto_11;
            					}
            					/* default */{
HXLINE( 792)						int this3 = 0;
HXDLIN( 792)						int rgba2 = this3;
HXDLIN( 792)						rgba2 = ((((((hx::UShr(color,16) & 255) & 255) << 24) | (((hx::UShr(color,8) & 255) & 255) << 16)) | (((color & 255) & 255) << 8)) | ((hx::UShr(color,24) & 255) & 255));
HXDLIN( 792)						int rgba3 = rgba2;
HXLINE( 793)						return rgba3;
            					}
            					_hx_goto_11:;
            				}
            			}
            			break;
            			default:{
HXLINE( 797)				return 0;
            			}
            		}
HXLINE( 770)		return 0;
            	}


HX_DEFINE_DYNAMIC_FUNC3(Image_obj,getPixel,return )

int Image_obj::getPixel32(int x,int y, ::Dynamic format){
            	HX_STACKFRAME(&_hx_pos_ef8f6e7e24e3b831_809_getPixel32)
HXLINE( 810)		bool _hx_tmp;
HXDLIN( 810)		bool _hx_tmp1;
HXDLIN( 810)		bool _hx_tmp2;
HXDLIN( 810)		bool _hx_tmp3;
HXDLIN( 810)		if (hx::IsNotNull( this->buffer )) {
HXLINE( 810)			_hx_tmp3 = (x < 0);
            		}
            		else {
HXLINE( 810)			_hx_tmp3 = true;
            		}
HXDLIN( 810)		if (!(_hx_tmp3)) {
HXLINE( 810)			_hx_tmp2 = (y < 0);
            		}
            		else {
HXLINE( 810)			_hx_tmp2 = true;
            		}
HXDLIN( 810)		if (!(_hx_tmp2)) {
HXLINE( 810)			_hx_tmp1 = (x >= this->width);
            		}
            		else {
HXLINE( 810)			_hx_tmp1 = true;
            		}
HXDLIN( 810)		if (!(_hx_tmp1)) {
HXLINE( 810)			_hx_tmp = (y >= this->height);
            		}
            		else {
HXLINE( 810)			_hx_tmp = true;
            		}
HXDLIN( 810)		if (_hx_tmp) {
HXLINE( 810)			return 0;
            		}
HXLINE( 812)		switch((int)(this->type->_hx_getIndex())){
            			case (int)0: {
HXLINE( 815)				return ::lime::_internal::graphics::ImageCanvasUtil_obj::getPixel32(hx::ObjectPtr<OBJ_>(this),x,y,( (int)(format) ));
            			}
            			break;
            			case (int)1: {
HXLINE( 822)				return ::lime::_internal::graphics::ImageDataUtil_obj::getPixel32(hx::ObjectPtr<OBJ_>(this),x,y,( (int)(format) ));
            			}
            			break;
            			case (int)2: {
HXLINE( 825)				int color = ( (int)(this->buffer->_hx___srcBitmapData->__Field(HX_("getPixel32",af,a6,68,d7),hx::paccDynamic)((x + this->offsetX),(y + this->offsetY))) );
HXLINE( 827)				if (hx::IsNull( format )) {
HXLINE( 834)					int this1 = 0;
HXDLIN( 834)					int rgba = this1;
HXDLIN( 834)					rgba = ((((((hx::UShr(color,16) & 255) & 255) << 24) | (((hx::UShr(color,8) & 255) & 255) << 16)) | (((color & 255) & 255) << 8)) | ((hx::UShr(color,24) & 255) & 255));
HXDLIN( 834)					int rgba1 = rgba;
HXLINE( 835)					return rgba1;
            				}
            				else {
HXLINE( 827)					 ::Dynamic _hx_switch_0 = format;
            					if (  (_hx_switch_0==1) ){
HXLINE( 829)						return color;
HXDLIN( 829)						goto _hx_goto_13;
            					}
            					if (  (_hx_switch_0==2) ){
HXLINE( 831)						int this2 = 0;
HXDLIN( 831)						int bgra = this2;
HXDLIN( 831)						bgra = ((((((color & 255) & 255) << 24) | (((hx::UShr(color,8) & 255) & 255) << 16)) | (((hx::UShr(color,16) & 255) & 255) << 8)) | ((hx::UShr(color,24) & 255) & 255));
HXDLIN( 831)						int bgra1 = bgra;
HXLINE( 832)						return bgra1;
HXLINE( 830)						goto _hx_goto_13;
            					}
            					/* default */{
HXLINE( 834)						int this3 = 0;
HXDLIN( 834)						int rgba2 = this3;
HXDLIN( 834)						rgba2 = ((((((hx::UShr(color,16) & 255) & 255) << 24) | (((hx::UShr(color,8) & 255) & 255) << 16)) | (((color & 255) & 255) << 8)) | ((hx::UShr(color,24) & 255) & 255));
HXDLIN( 834)						int rgba3 = rgba2;
HXLINE( 835)						return rgba3;
            					}
            					_hx_goto_13:;
            				}
            			}
            			break;
            			default:{
HXLINE( 839)				return 0;
            			}
            		}
HXLINE( 812)		return 0;
            	}


HX_DEFINE_DYNAMIC_FUNC3(Image_obj,getPixel32,return )

 ::haxe::io::Bytes Image_obj::getPixels( ::lime::math::Rectangle rect, ::Dynamic format){
            	HX_STACKFRAME(&_hx_pos_ef8f6e7e24e3b831_850_getPixels)
HXLINE( 851)		if (hx::IsNull( this->buffer )) {
HXLINE( 851)			return null();
            		}
HXLINE( 853)		switch((int)(this->type->_hx_getIndex())){
            			case (int)0: {
HXLINE( 856)				return ::lime::_internal::graphics::ImageCanvasUtil_obj::getPixels(hx::ObjectPtr<OBJ_>(this),rect,( (int)(format) ));
            			}
            			break;
            			case (int)1: {
HXLINE( 863)				return ::lime::_internal::graphics::ImageDataUtil_obj::getPixels(hx::ObjectPtr<OBJ_>(this),rect,( (int)(format) ));
            			}
            			break;
            			case (int)2: {
HXLINE( 902)				return null();
            			}
            			break;
            			default:{
HXLINE( 906)				return null();
            			}
            		}
HXLINE( 853)		return null();
            	}


HX_DEFINE_DYNAMIC_FUNC2(Image_obj,getPixels,return )

void Image_obj::merge( ::lime::graphics::Image sourceImage, ::lime::math::Rectangle sourceRect, ::lime::math::Vector2 destPoint,int redMultiplier,int greenMultiplier,int blueMultiplier,int alphaMultiplier){
            	HX_STACKFRAME(&_hx_pos_ef8f6e7e24e3b831_1079_merge)
HXLINE(1080)		bool _hx_tmp;
HXDLIN(1080)		if (hx::IsNotNull( this->buffer )) {
HXLINE(1080)			_hx_tmp = hx::IsNull( sourceImage );
            		}
            		else {
HXLINE(1080)			_hx_tmp = true;
            		}
HXDLIN(1080)		if (_hx_tmp) {
HXLINE(1080)			return;
            		}
HXLINE(1082)		switch((int)(this->type->_hx_getIndex())){
            			case (int)0: {
HXLINE(1085)				::lime::_internal::graphics::ImageCanvasUtil_obj::convertToCanvas(hx::ObjectPtr<OBJ_>(this),null());
HXLINE(1086)				::lime::_internal::graphics::ImageCanvasUtil_obj::merge(hx::ObjectPtr<OBJ_>(this),sourceImage,sourceRect,destPoint,redMultiplier,greenMultiplier,blueMultiplier,alphaMultiplier);
            			}
            			break;
            			case (int)1: {
HXLINE(1094)				::lime::_internal::graphics::ImageDataUtil_obj::merge(hx::ObjectPtr<OBJ_>(this),sourceImage,sourceRect,destPoint,redMultiplier,greenMultiplier,blueMultiplier,alphaMultiplier);
            			}
            			break;
            			case (int)2: {
HXLINE(1097)				sourceRect->offset(( (Float)(this->offsetX) ),( (Float)(this->offsetY) ));
HXLINE(1098)				 ::Dynamic _hx_tmp1 =  ::Dynamic(this->buffer->_hx___srcBitmapData->__Field(HX_("merge",b8,a2,c6,05),hx::paccDynamic));
HXDLIN(1098)				 ::Dynamic sourceImage1 = sourceImage->buffer->_hx___srcBitmapData;
HXDLIN(1098)				 ::Dynamic _hx_tmp2 = sourceRect->_hx___toFlashRectangle();
HXDLIN(1098)				_hx_tmp1(sourceImage1,_hx_tmp2,destPoint->_hx___toFlashPoint(),redMultiplier,greenMultiplier,blueMultiplier,alphaMultiplier);
            			}
            			break;
            			default:{
HXLINE(1102)				return;
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC7(Image_obj,merge,(void))

void Image_obj::resize(int newWidth,int newHeight){
            	HX_STACKFRAME(&_hx_pos_ef8f6e7e24e3b831_1113_resize)
HXLINE(1114)		switch((int)(this->type->_hx_getIndex())){
            			case (int)0: {
HXLINE(1117)				::lime::_internal::graphics::ImageCanvasUtil_obj::resize(hx::ObjectPtr<OBJ_>(this),newWidth,newHeight);
            			}
            			break;
            			case (int)1: {
HXLINE(1120)				::lime::_internal::graphics::ImageDataUtil_obj::resize(hx::ObjectPtr<OBJ_>(this),newWidth,newHeight);
            			}
            			break;
            			case (int)2: {
            			}
            			break;
            			default:{
            			}
            		}
HXLINE(1134)		this->buffer->width = newWidth;
HXLINE(1135)		this->buffer->height = newHeight;
HXLINE(1137)		this->offsetX = 0;
HXLINE(1138)		this->offsetY = 0;
HXLINE(1139)		this->width = newWidth;
HXLINE(1140)		this->height = newHeight;
            	}


HX_DEFINE_DYNAMIC_FUNC2(Image_obj,resize,(void))

void Image_obj::scroll(int x,int y){
            	HX_GC_STACKFRAME(&_hx_pos_ef8f6e7e24e3b831_1153_scroll)
HXLINE(1154)		if (hx::IsNull( this->buffer )) {
HXLINE(1154)			return;
            		}
HXLINE(1156)		switch((int)(this->type->_hx_getIndex())){
            			case (int)0: {
HXLINE(1159)				::lime::_internal::graphics::ImageCanvasUtil_obj::scroll(hx::ObjectPtr<OBJ_>(this),x,y);
            			}
            			break;
            			case (int)1: {
HXLINE(1162)				 ::lime::math::Rectangle _hx_tmp = this->get_rect();
HXDLIN(1162)				this->copyPixels(hx::ObjectPtr<OBJ_>(this),_hx_tmp, ::lime::math::Vector2_obj::__alloc( HX_CTX ,x,y),null(),null(),null());
            			}
            			break;
            			case (int)2: {
HXLINE(1165)				this->buffer->_hx___srcBitmapData->__Field(HX_("scroll",0d,d8,64,47),hx::paccDynamic)((x + this->offsetX),(y + this->offsetX));
            			}
            			break;
            			default:{
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC2(Image_obj,scroll,(void))

void Image_obj::setPixel(int x,int y,int color, ::Dynamic format){
            	HX_STACKFRAME(&_hx_pos_ef8f6e7e24e3b831_1179_setPixel)
HXLINE(1180)		bool _hx_tmp;
HXDLIN(1180)		bool _hx_tmp1;
HXDLIN(1180)		bool _hx_tmp2;
HXDLIN(1180)		bool _hx_tmp3;
HXDLIN(1180)		if (hx::IsNotNull( this->buffer )) {
HXLINE(1180)			_hx_tmp3 = (x < 0);
            		}
            		else {
HXLINE(1180)			_hx_tmp3 = true;
            		}
HXDLIN(1180)		if (!(_hx_tmp3)) {
HXLINE(1180)			_hx_tmp2 = (y < 0);
            		}
            		else {
HXLINE(1180)			_hx_tmp2 = true;
            		}
HXDLIN(1180)		if (!(_hx_tmp2)) {
HXLINE(1180)			_hx_tmp1 = (x >= this->width);
            		}
            		else {
HXLINE(1180)			_hx_tmp1 = true;
            		}
HXDLIN(1180)		if (!(_hx_tmp1)) {
HXLINE(1180)			_hx_tmp = (y >= this->height);
            		}
            		else {
HXLINE(1180)			_hx_tmp = true;
            		}
HXDLIN(1180)		if (_hx_tmp) {
HXLINE(1180)			return;
            		}
HXLINE(1182)		switch((int)(this->type->_hx_getIndex())){
            			case (int)0: {
HXLINE(1185)				::lime::_internal::graphics::ImageCanvasUtil_obj::setPixel(hx::ObjectPtr<OBJ_>(this),x,y,color,( (int)(format) ));
            			}
            			break;
            			case (int)1: {
HXLINE(1192)				::lime::_internal::graphics::ImageDataUtil_obj::setPixel(hx::ObjectPtr<OBJ_>(this),x,y,color,( (int)(format) ));
            			}
            			break;
            			case (int)2: {
HXLINE(1195)				int argb;
HXDLIN(1195)				if (hx::IsNull( format )) {
HXLINE(1199)					int rgba = color;
HXDLIN(1199)					int this1 = 0;
HXDLIN(1199)					int argb1 = this1;
HXDLIN(1199)					argb1 = ((((((rgba & 255) & 255) << 24) | (((hx::UShr(rgba,24) & 255) & 255) << 16)) | (((hx::UShr(rgba,16) & 255) & 255) << 8)) | ((hx::UShr(rgba,8) & 255) & 255));
HXLINE(1195)					argb = argb1;
            				}
            				else {
HXLINE(1195)					 ::Dynamic _hx_switch_0 = format;
            					if (  (_hx_switch_0==1) ){
HXLINE(1195)						argb = color;
HXDLIN(1195)						goto _hx_goto_19;
            					}
            					if (  (_hx_switch_0==2) ){
HXLINE(1198)						int bgra = color;
HXDLIN(1198)						int this2 = 0;
HXDLIN(1198)						int argb2 = this2;
HXDLIN(1198)						argb2 = ((((((bgra & 255) & 255) << 24) | (((hx::UShr(bgra,8) & 255) & 255) << 16)) | (((hx::UShr(bgra,16) & 255) & 255) << 8)) | ((hx::UShr(bgra,24) & 255) & 255));
HXLINE(1195)						argb = argb2;
HXLINE(1198)						goto _hx_goto_19;
            					}
            					/* default */{
HXLINE(1199)						int rgba1 = color;
HXDLIN(1199)						int this3 = 0;
HXDLIN(1199)						int argb3 = this3;
HXDLIN(1199)						argb3 = ((((((rgba1 & 255) & 255) << 24) | (((hx::UShr(rgba1,24) & 255) & 255) << 16)) | (((hx::UShr(rgba1,16) & 255) & 255) << 8)) | ((hx::UShr(rgba1,8) & 255) & 255));
HXLINE(1195)						argb = argb3;
            					}
            					_hx_goto_19:;
            				}
HXLINE(1202)				this->buffer->_hx___srcBitmapData->__Field(HX_("setPixel",84,2f,d8,d0),hx::paccDynamic)((x + this->offsetX),(y + this->offsetX),argb);
            			}
            			break;
            			default:{
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC4(Image_obj,setPixel,(void))

void Image_obj::setPixel32(int x,int y,int color, ::Dynamic format){
            	HX_STACKFRAME(&_hx_pos_ef8f6e7e24e3b831_1216_setPixel32)
HXLINE(1217)		bool _hx_tmp;
HXDLIN(1217)		bool _hx_tmp1;
HXDLIN(1217)		bool _hx_tmp2;
HXDLIN(1217)		bool _hx_tmp3;
HXDLIN(1217)		if (hx::IsNotNull( this->buffer )) {
HXLINE(1217)			_hx_tmp3 = (x < 0);
            		}
            		else {
HXLINE(1217)			_hx_tmp3 = true;
            		}
HXDLIN(1217)		if (!(_hx_tmp3)) {
HXLINE(1217)			_hx_tmp2 = (y < 0);
            		}
            		else {
HXLINE(1217)			_hx_tmp2 = true;
            		}
HXDLIN(1217)		if (!(_hx_tmp2)) {
HXLINE(1217)			_hx_tmp1 = (x >= this->width);
            		}
            		else {
HXLINE(1217)			_hx_tmp1 = true;
            		}
HXDLIN(1217)		if (!(_hx_tmp1)) {
HXLINE(1217)			_hx_tmp = (y >= this->height);
            		}
            		else {
HXLINE(1217)			_hx_tmp = true;
            		}
HXDLIN(1217)		if (_hx_tmp) {
HXLINE(1217)			return;
            		}
HXLINE(1219)		switch((int)(this->type->_hx_getIndex())){
            			case (int)0: {
HXLINE(1222)				::lime::_internal::graphics::ImageCanvasUtil_obj::setPixel32(hx::ObjectPtr<OBJ_>(this),x,y,color,( (int)(format) ));
            			}
            			break;
            			case (int)1: {
HXLINE(1229)				::lime::_internal::graphics::ImageDataUtil_obj::setPixel32(hx::ObjectPtr<OBJ_>(this),x,y,color,( (int)(format) ));
            			}
            			break;
            			case (int)2: {
HXLINE(1232)				int argb;
HXDLIN(1232)				if (hx::IsNull( format )) {
HXLINE(1236)					int rgba = color;
HXDLIN(1236)					int this1 = 0;
HXDLIN(1236)					int argb1 = this1;
HXDLIN(1236)					argb1 = ((((((rgba & 255) & 255) << 24) | (((hx::UShr(rgba,24) & 255) & 255) << 16)) | (((hx::UShr(rgba,16) & 255) & 255) << 8)) | ((hx::UShr(rgba,8) & 255) & 255));
HXLINE(1232)					argb = argb1;
            				}
            				else {
HXLINE(1232)					 ::Dynamic _hx_switch_0 = format;
            					if (  (_hx_switch_0==1) ){
HXLINE(1232)						argb = color;
HXDLIN(1232)						goto _hx_goto_21;
            					}
            					if (  (_hx_switch_0==2) ){
HXLINE(1235)						int bgra = color;
HXDLIN(1235)						int this2 = 0;
HXDLIN(1235)						int argb2 = this2;
HXDLIN(1235)						argb2 = ((((((bgra & 255) & 255) << 24) | (((hx::UShr(bgra,8) & 255) & 255) << 16)) | (((hx::UShr(bgra,16) & 255) & 255) << 8)) | ((hx::UShr(bgra,24) & 255) & 255));
HXLINE(1232)						argb = argb2;
HXLINE(1235)						goto _hx_goto_21;
            					}
            					/* default */{
HXLINE(1236)						int rgba1 = color;
HXDLIN(1236)						int this3 = 0;
HXDLIN(1236)						int argb3 = this3;
HXDLIN(1236)						argb3 = ((((((rgba1 & 255) & 255) << 24) | (((hx::UShr(rgba1,24) & 255) & 255) << 16)) | (((hx::UShr(rgba1,16) & 255) & 255) << 8)) | ((hx::UShr(rgba1,8) & 255) & 255));
HXLINE(1232)						argb = argb3;
            					}
            					_hx_goto_21:;
            				}
HXLINE(1239)				this->buffer->_hx___srcBitmapData->__Field(HX_("setPixel32",23,45,e6,da),hx::paccDynamic)((x + this->offsetX),(y + this->offsetY),argb);
            			}
            			break;
            			default:{
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC4(Image_obj,setPixel32,(void))

void Image_obj::setPixels( ::lime::math::Rectangle rect, ::lime::utils::BytePointerData bytePointer, ::Dynamic format, ::lime::_hx_system::Endian endian){
            	HX_STACKFRAME(&_hx_pos_ef8f6e7e24e3b831_1253_setPixels)
HXLINE(1254)		rect = this->_hx___clipRect(rect);
HXLINE(1255)		bool _hx_tmp;
HXDLIN(1255)		if (hx::IsNotNull( this->buffer )) {
HXLINE(1255)			_hx_tmp = hx::IsNull( rect );
            		}
            		else {
HXLINE(1255)			_hx_tmp = true;
            		}
HXDLIN(1255)		if (_hx_tmp) {
HXLINE(1255)			return;
            		}
HXLINE(1256)		if (hx::IsNull( endian )) {
HXLINE(1256)			endian = ::lime::_hx_system::Endian_obj::_hx_BIG_ENDIAN_dyn();
            		}
HXLINE(1258)		switch((int)(this->type->_hx_getIndex())){
            			case (int)0: {
HXLINE(1261)				::lime::_internal::graphics::ImageCanvasUtil_obj::setPixels(hx::ObjectPtr<OBJ_>(this),rect,bytePointer,( (int)(format) ),endian);
            			}
            			break;
            			case (int)1: {
HXLINE(1268)				::lime::_internal::graphics::ImageDataUtil_obj::setPixels(hx::ObjectPtr<OBJ_>(this),rect,bytePointer,( (int)(format) ),endian);
            			}
            			break;
            			case (int)2: {
            			}
            			break;
            			default:{
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC4(Image_obj,setPixels,(void))

int Image_obj::threshold( ::lime::graphics::Image sourceImage, ::lime::math::Rectangle sourceRect, ::lime::math::Vector2 destPoint,::String operation,int threshold,hx::Null< int >  __o_color,hx::Null< int >  __o_mask,hx::Null< bool >  __o_copySource, ::Dynamic format){
            		int color = __o_color.Default(0);
            		int mask = __o_mask.Default(-1);
            		bool copySource = __o_copySource.Default(false);
            	HX_STACKFRAME(&_hx_pos_ef8f6e7e24e3b831_1360_threshold)
HXLINE(1361)		bool _hx_tmp;
HXDLIN(1361)		bool _hx_tmp1;
HXDLIN(1361)		if (hx::IsNotNull( this->buffer )) {
HXLINE(1361)			_hx_tmp1 = hx::IsNull( sourceImage );
            		}
            		else {
HXLINE(1361)			_hx_tmp1 = true;
            		}
HXDLIN(1361)		if (!(_hx_tmp1)) {
HXLINE(1361)			_hx_tmp = hx::IsNull( sourceRect );
            		}
            		else {
HXLINE(1361)			_hx_tmp = true;
            		}
HXDLIN(1361)		if (_hx_tmp) {
HXLINE(1361)			return 0;
            		}
HXLINE(1363)		switch((int)(this->type->_hx_getIndex())){
            			case (int)0: case (int)1: {
HXLINE(1371)				return ::lime::_internal::graphics::ImageDataUtil_obj::threshold(hx::ObjectPtr<OBJ_>(this),sourceImage,sourceRect,destPoint,operation,threshold,color,mask,copySource,( (int)(format) ));
            			}
            			break;
            			case (int)2: {
HXLINE(1374)				int _color;
HXDLIN(1374)				if (hx::IsNull( format )) {
HXLINE(1378)					int rgba = color;
HXDLIN(1378)					int this1 = 0;
HXDLIN(1378)					int argb = this1;
HXDLIN(1378)					argb = ((((((rgba & 255) & 255) << 24) | (((hx::UShr(rgba,24) & 255) & 255) << 16)) | (((hx::UShr(rgba,16) & 255) & 255) << 8)) | ((hx::UShr(rgba,8) & 255) & 255));
HXLINE(1374)					_color = argb;
            				}
            				else {
HXLINE(1374)					 ::Dynamic _hx_switch_0 = format;
            					if (  (_hx_switch_0==1) ){
HXLINE(1374)						_color = color;
HXDLIN(1374)						goto _hx_goto_24;
            					}
            					if (  (_hx_switch_0==2) ){
HXLINE(1377)						int bgra = color;
HXDLIN(1377)						int this2 = 0;
HXDLIN(1377)						int argb1 = this2;
HXDLIN(1377)						argb1 = ((((((bgra & 255) & 255) << 24) | (((hx::UShr(bgra,8) & 255) & 255) << 16)) | (((hx::UShr(bgra,16) & 255) & 255) << 8)) | ((hx::UShr(bgra,24) & 255) & 255));
HXLINE(1374)						_color = argb1;
HXLINE(1377)						goto _hx_goto_24;
            					}
            					/* default */{
HXLINE(1378)						int rgba1 = color;
HXDLIN(1378)						int this3 = 0;
HXDLIN(1378)						int argb2 = this3;
HXDLIN(1378)						argb2 = ((((((rgba1 & 255) & 255) << 24) | (((hx::UShr(rgba1,24) & 255) & 255) << 16)) | (((hx::UShr(rgba1,16) & 255) & 255) << 8)) | ((hx::UShr(rgba1,8) & 255) & 255));
HXLINE(1374)						_color = argb2;
            					}
            					_hx_goto_24:;
            				}
HXLINE(1381)				int _mask;
HXDLIN(1381)				if (hx::IsNull( format )) {
HXLINE(1385)					int rgba2 = mask;
HXDLIN(1385)					int this4 = 0;
HXDLIN(1385)					int argb3 = this4;
HXDLIN(1385)					argb3 = ((((((rgba2 & 255) & 255) << 24) | (((hx::UShr(rgba2,24) & 255) & 255) << 16)) | (((hx::UShr(rgba2,16) & 255) & 255) << 8)) | ((hx::UShr(rgba2,8) & 255) & 255));
HXLINE(1381)					_mask = argb3;
            				}
            				else {
HXLINE(1381)					 ::Dynamic _hx_switch_1 = format;
            					if (  (_hx_switch_1==1) ){
HXLINE(1381)						_mask = mask;
HXDLIN(1381)						goto _hx_goto_25;
            					}
            					if (  (_hx_switch_1==2) ){
HXLINE(1384)						int bgra1 = mask;
HXDLIN(1384)						int this5 = 0;
HXDLIN(1384)						int argb4 = this5;
HXDLIN(1384)						argb4 = ((((((bgra1 & 255) & 255) << 24) | (((hx::UShr(bgra1,8) & 255) & 255) << 16)) | (((hx::UShr(bgra1,16) & 255) & 255) << 8)) | ((hx::UShr(bgra1,24) & 255) & 255));
HXLINE(1381)						_mask = argb4;
HXLINE(1384)						goto _hx_goto_25;
            					}
            					/* default */{
HXLINE(1385)						int rgba3 = mask;
HXDLIN(1385)						int this6 = 0;
HXDLIN(1385)						int argb5 = this6;
HXDLIN(1385)						argb5 = ((((((rgba3 & 255) & 255) << 24) | (((hx::UShr(rgba3,24) & 255) & 255) << 16)) | (((hx::UShr(rgba3,16) & 255) & 255) << 8)) | ((hx::UShr(rgba3,8) & 255) & 255));
HXLINE(1381)						_mask = argb5;
            					}
            					_hx_goto_25:;
            				}
HXLINE(1388)				sourceRect->offset(( (Float)(sourceImage->offsetX) ),( (Float)(sourceImage->offsetY) ));
HXLINE(1389)				destPoint->offset(( (Float)(this->offsetX) ),( (Float)(this->offsetY) ));
HXLINE(1391)				 ::Dynamic _hx_tmp2 =  ::Dynamic(this->buffer->_hx___srcBitmapData->__Field(HX_("threshold",ab,c3,a3,34),hx::paccDynamic));
HXDLIN(1391)				 ::Dynamic _hx_tmp3 = sourceImage->buffer->get_src();
HXDLIN(1391)				 ::Dynamic _hx_tmp4 = sourceRect->_hx___toFlashRectangle();
HXDLIN(1391)				return ( (int)(_hx_tmp2(_hx_tmp3,_hx_tmp4,destPoint->_hx___toFlashPoint(),operation,threshold,_color,_mask,copySource)) );
            			}
            			break;
            			default:{
            			}
            		}
HXLINE(1397)		return 0;
            	}


HX_DEFINE_DYNAMIC_FUNC9(Image_obj,threshold,return )

 ::lime::math::Rectangle Image_obj::_hx___clipRect( ::lime::math::Rectangle r){
            	HX_STACKFRAME(&_hx_pos_ef8f6e7e24e3b831_1401___clipRect)
HXLINE(1402)		if (hx::IsNull( r )) {
HXLINE(1402)			return null();
            		}
HXLINE(1404)		if ((r->x < 0)) {
HXLINE(1406)			 ::lime::math::Rectangle r1 = r;
HXDLIN(1406)			r1->width = (r1->width - -(r->x));
HXLINE(1407)			r->x = ( (Float)(0) );
HXLINE(1409)			if (((r->x + r->width) <= 0)) {
HXLINE(1409)				return null();
            			}
            		}
HXLINE(1412)		if ((r->y < 0)) {
HXLINE(1414)			 ::lime::math::Rectangle r2 = r;
HXDLIN(1414)			r2->height = (r2->height - -(r->y));
HXLINE(1415)			r->y = ( (Float)(0) );
HXLINE(1417)			if (((r->y + r->height) <= 0)) {
HXLINE(1417)				return null();
            			}
            		}
HXLINE(1420)		if (((r->x + r->width) >= this->width)) {
HXLINE(1422)			 ::lime::math::Rectangle r3 = r;
HXDLIN(1422)			r3->width = (r3->width - ((r->x + r->width) - ( (Float)(this->width) )));
HXLINE(1424)			if ((r->width <= 0)) {
HXLINE(1424)				return null();
            			}
            		}
HXLINE(1427)		if (((r->y + r->height) >= this->height)) {
HXLINE(1429)			 ::lime::math::Rectangle r4 = r;
HXDLIN(1429)			r4->height = (r4->height - ((r->y + r->height) - ( (Float)(this->height) )));
HXLINE(1431)			if ((r->height <= 0)) {
HXLINE(1431)				return null();
            			}
            		}
HXLINE(1434)		return r;
            	}


HX_DEFINE_DYNAMIC_FUNC1(Image_obj,_hx___clipRect,return )

void Image_obj::_hx___fromBase64(::String base64,::String type, ::Dynamic onload){
            	HX_STACKFRAME(&_hx_pos_ef8f6e7e24e3b831_1465___fromBase64)
HXDLIN(1465)		if (hx::IsNotNull( base64 )) {
HXLINE(1467)			this->_hx___fromBytes(::lime::_internal::format::Base64_obj::decode(base64),null());
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC3(Image_obj,_hx___fromBase64,(void))

bool Image_obj::_hx___fromBytes( ::haxe::io::Bytes bytes, ::Dynamic onload){
            	HX_GC_STACKFRAME(&_hx_pos_ef8f6e7e24e3b831_1473___fromBytes)
HXLINE(1498)		 ::lime::graphics::ImageBuffer imageBuffer = null();
HXLINE(1501)		 ::Dynamic elements = null();
HXDLIN(1501)		 ::haxe::io::Bytes buffer = ::haxe::io::Bytes_obj::alloc(0);
HXDLIN(1501)		::cpp::VirtualArray array = null();
HXDLIN(1501)		 ::openfl::_Vector::IntVector vector = null();
HXDLIN(1501)		 ::lime::utils::ArrayBufferView view = null();
HXDLIN(1501)		 ::Dynamic len = null();
HXDLIN(1501)		 ::lime::utils::ArrayBufferView this1;
HXDLIN(1501)		if (hx::IsNotNull( elements )) {
HXLINE(1501)			this1 =  ::lime::utils::ArrayBufferView_obj::__alloc( HX_CTX ,elements,4);
            		}
            		else {
HXLINE(1501)			if (hx::IsNotNull( array )) {
HXLINE(1501)				 ::lime::utils::ArrayBufferView _this =  ::lime::utils::ArrayBufferView_obj::__alloc( HX_CTX ,0,4);
HXDLIN(1501)				_this->byteOffset = 0;
HXDLIN(1501)				_this->length = array->get_length();
HXDLIN(1501)				_this->byteLength = (_this->length * _this->bytesPerElement);
HXDLIN(1501)				 ::haxe::io::Bytes this2 = ::haxe::io::Bytes_obj::alloc(_this->byteLength);
HXDLIN(1501)				_this->buffer = this2;
HXDLIN(1501)				_this->copyFromArray(array,null());
HXDLIN(1501)				this1 = _this;
            			}
            			else {
HXLINE(1501)				if (hx::IsNotNull( vector )) {
HXLINE(1501)					 ::lime::utils::ArrayBufferView _this1 =  ::lime::utils::ArrayBufferView_obj::__alloc( HX_CTX ,0,4);
HXDLIN(1501)					::cpp::VirtualArray array1 = ( (::cpp::VirtualArray)(vector->__Field(HX_("__array",79,c6,ed,8f),hx::paccDynamic)) );
HXDLIN(1501)					_this1->byteOffset = 0;
HXDLIN(1501)					_this1->length = array1->get_length();
HXDLIN(1501)					_this1->byteLength = (_this1->length * _this1->bytesPerElement);
HXDLIN(1501)					 ::haxe::io::Bytes this3 = ::haxe::io::Bytes_obj::alloc(_this1->byteLength);
HXDLIN(1501)					_this1->buffer = this3;
HXDLIN(1501)					_this1->copyFromArray(array1,null());
HXDLIN(1501)					this1 = _this1;
            				}
            				else {
HXLINE(1501)					if (hx::IsNotNull( view )) {
HXLINE(1501)						 ::lime::utils::ArrayBufferView _this2 =  ::lime::utils::ArrayBufferView_obj::__alloc( HX_CTX ,0,4);
HXDLIN(1501)						 ::haxe::io::Bytes srcData = view->buffer;
HXDLIN(1501)						int srcLength = view->length;
HXDLIN(1501)						int srcByteOffset = view->byteOffset;
HXDLIN(1501)						int srcElementSize = view->bytesPerElement;
HXDLIN(1501)						int elementSize = _this2->bytesPerElement;
HXDLIN(1501)						if ((view->type == _this2->type)) {
HXLINE(1501)							int srcLength1 = srcData->length;
HXDLIN(1501)							int cloneLength = (srcLength1 - srcByteOffset);
HXDLIN(1501)							 ::haxe::io::Bytes this4 = ::haxe::io::Bytes_obj::alloc(cloneLength);
HXDLIN(1501)							_this2->buffer = this4;
HXDLIN(1501)							_this2->buffer->blit(0,srcData,srcByteOffset,cloneLength);
            						}
            						else {
HXLINE(1501)							HX_STACK_DO_THROW(HX_("unimplemented",09,2f,74,b4));
            						}
HXDLIN(1501)						_this2->byteLength = (_this2->bytesPerElement * srcLength);
HXDLIN(1501)						_this2->byteOffset = 0;
HXDLIN(1501)						_this2->length = srcLength;
HXDLIN(1501)						this1 = _this2;
            					}
            					else {
HXLINE(1501)						if (hx::IsNotNull( buffer )) {
HXLINE(1501)							 ::lime::utils::ArrayBufferView _this3 =  ::lime::utils::ArrayBufferView_obj::__alloc( HX_CTX ,0,4);
HXDLIN(1501)							int in_byteOffset = 0;
HXDLIN(1501)							if ((in_byteOffset < 0)) {
HXLINE(1501)								HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            							}
HXDLIN(1501)							if ((hx::Mod(in_byteOffset,_this3->bytesPerElement) != 0)) {
HXLINE(1501)								HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            							}
HXDLIN(1501)							int bufferByteLength = buffer->length;
HXDLIN(1501)							int elementSize1 = _this3->bytesPerElement;
HXDLIN(1501)							int newByteLength = bufferByteLength;
HXDLIN(1501)							if (hx::IsNull( len )) {
HXLINE(1501)								newByteLength = (bufferByteLength - in_byteOffset);
HXDLIN(1501)								if ((hx::Mod(bufferByteLength,_this3->bytesPerElement) != 0)) {
HXLINE(1501)									HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            								}
HXDLIN(1501)								if ((newByteLength < 0)) {
HXLINE(1501)									HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            								}
            							}
            							else {
HXLINE(1501)								newByteLength = (( (int)(len) ) * _this3->bytesPerElement);
HXDLIN(1501)								int newRange = (in_byteOffset + newByteLength);
HXDLIN(1501)								if ((newRange > bufferByteLength)) {
HXLINE(1501)									HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            								}
            							}
HXDLIN(1501)							_this3->buffer = buffer;
HXDLIN(1501)							_this3->byteOffset = in_byteOffset;
HXDLIN(1501)							_this3->byteLength = newByteLength;
HXDLIN(1501)							_this3->length = ::Std_obj::_hx_int((( (Float)(newByteLength) ) / ( (Float)(_this3->bytesPerElement) )));
HXDLIN(1501)							this1 = _this3;
            						}
            						else {
HXLINE(1501)							HX_STACK_DO_THROW(HX_("Invalid constructor arguments for UInt8Array",6b,44,d5,85));
            						}
            					}
            				}
            			}
            		}
HXDLIN(1501)		imageBuffer = ( ( ::Dynamic)(::lime::_internal::backend::native::NativeCFFI_obj::lime_image_load_bytes(hx::DynamicPtr(bytes),hx::DynamicPtr( ::lime::graphics::ImageBuffer_obj::__alloc( HX_CTX ,this1,null(),null(),null(),null())))) );
HXLINE(1511)		if (hx::IsNotNull( imageBuffer )) {
HXLINE(1513)			this->_hx___fromImageBuffer(imageBuffer);
HXLINE(1515)			if (hx::IsNotNull( onload )) {
HXLINE(1517)				onload(hx::ObjectPtr<OBJ_>(this));
            			}
HXLINE(1520)			return true;
            		}
HXLINE(1526)		return false;
            	}


HX_DEFINE_DYNAMIC_FUNC2(Image_obj,_hx___fromBytes,return )

bool Image_obj::_hx___fromFile(::String path, ::Dynamic onload, ::Dynamic onerror){
            	HX_GC_STACKFRAME(&_hx_pos_ef8f6e7e24e3b831_1530___fromFile)
HXLINE(1619)		 ::lime::graphics::ImageBuffer buffer = null();
HXLINE(1624)		if (::lime::_hx_system::CFFI_obj::enabled) {
HXLINE(1627)			 ::Dynamic elements = null();
HXDLIN(1627)			 ::haxe::io::Bytes buffer1 = ::haxe::io::Bytes_obj::alloc(0);
HXDLIN(1627)			::cpp::VirtualArray array = null();
HXDLIN(1627)			 ::openfl::_Vector::IntVector vector = null();
HXDLIN(1627)			 ::lime::utils::ArrayBufferView view = null();
HXDLIN(1627)			 ::Dynamic len = null();
HXDLIN(1627)			 ::lime::utils::ArrayBufferView this1;
HXDLIN(1627)			if (hx::IsNotNull( elements )) {
HXLINE(1627)				this1 =  ::lime::utils::ArrayBufferView_obj::__alloc( HX_CTX ,elements,4);
            			}
            			else {
HXLINE(1627)				if (hx::IsNotNull( array )) {
HXLINE(1627)					 ::lime::utils::ArrayBufferView _this =  ::lime::utils::ArrayBufferView_obj::__alloc( HX_CTX ,0,4);
HXDLIN(1627)					_this->byteOffset = 0;
HXDLIN(1627)					_this->length = array->get_length();
HXDLIN(1627)					_this->byteLength = (_this->length * _this->bytesPerElement);
HXDLIN(1627)					 ::haxe::io::Bytes this2 = ::haxe::io::Bytes_obj::alloc(_this->byteLength);
HXDLIN(1627)					_this->buffer = this2;
HXDLIN(1627)					_this->copyFromArray(array,null());
HXDLIN(1627)					this1 = _this;
            				}
            				else {
HXLINE(1627)					if (hx::IsNotNull( vector )) {
HXLINE(1627)						 ::lime::utils::ArrayBufferView _this1 =  ::lime::utils::ArrayBufferView_obj::__alloc( HX_CTX ,0,4);
HXDLIN(1627)						::cpp::VirtualArray array1 = ( (::cpp::VirtualArray)(vector->__Field(HX_("__array",79,c6,ed,8f),hx::paccDynamic)) );
HXDLIN(1627)						_this1->byteOffset = 0;
HXDLIN(1627)						_this1->length = array1->get_length();
HXDLIN(1627)						_this1->byteLength = (_this1->length * _this1->bytesPerElement);
HXDLIN(1627)						 ::haxe::io::Bytes this3 = ::haxe::io::Bytes_obj::alloc(_this1->byteLength);
HXDLIN(1627)						_this1->buffer = this3;
HXDLIN(1627)						_this1->copyFromArray(array1,null());
HXDLIN(1627)						this1 = _this1;
            					}
            					else {
HXLINE(1627)						if (hx::IsNotNull( view )) {
HXLINE(1627)							 ::lime::utils::ArrayBufferView _this2 =  ::lime::utils::ArrayBufferView_obj::__alloc( HX_CTX ,0,4);
HXDLIN(1627)							 ::haxe::io::Bytes srcData = view->buffer;
HXDLIN(1627)							int srcLength = view->length;
HXDLIN(1627)							int srcByteOffset = view->byteOffset;
HXDLIN(1627)							int srcElementSize = view->bytesPerElement;
HXDLIN(1627)							int elementSize = _this2->bytesPerElement;
HXDLIN(1627)							if ((view->type == _this2->type)) {
HXLINE(1627)								int srcLength1 = srcData->length;
HXDLIN(1627)								int cloneLength = (srcLength1 - srcByteOffset);
HXDLIN(1627)								 ::haxe::io::Bytes this4 = ::haxe::io::Bytes_obj::alloc(cloneLength);
HXDLIN(1627)								_this2->buffer = this4;
HXDLIN(1627)								_this2->buffer->blit(0,srcData,srcByteOffset,cloneLength);
            							}
            							else {
HXLINE(1627)								HX_STACK_DO_THROW(HX_("unimplemented",09,2f,74,b4));
            							}
HXDLIN(1627)							_this2->byteLength = (_this2->bytesPerElement * srcLength);
HXDLIN(1627)							_this2->byteOffset = 0;
HXDLIN(1627)							_this2->length = srcLength;
HXDLIN(1627)							this1 = _this2;
            						}
            						else {
HXLINE(1627)							if (hx::IsNotNull( buffer1 )) {
HXLINE(1627)								 ::lime::utils::ArrayBufferView _this3 =  ::lime::utils::ArrayBufferView_obj::__alloc( HX_CTX ,0,4);
HXDLIN(1627)								int in_byteOffset = 0;
HXDLIN(1627)								if ((in_byteOffset < 0)) {
HXLINE(1627)									HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            								}
HXDLIN(1627)								if ((hx::Mod(in_byteOffset,_this3->bytesPerElement) != 0)) {
HXLINE(1627)									HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            								}
HXDLIN(1627)								int bufferByteLength = buffer1->length;
HXDLIN(1627)								int elementSize1 = _this3->bytesPerElement;
HXDLIN(1627)								int newByteLength = bufferByteLength;
HXDLIN(1627)								if (hx::IsNull( len )) {
HXLINE(1627)									newByteLength = (bufferByteLength - in_byteOffset);
HXDLIN(1627)									if ((hx::Mod(bufferByteLength,_this3->bytesPerElement) != 0)) {
HXLINE(1627)										HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            									}
HXDLIN(1627)									if ((newByteLength < 0)) {
HXLINE(1627)										HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            									}
            								}
            								else {
HXLINE(1627)									newByteLength = (( (int)(len) ) * _this3->bytesPerElement);
HXDLIN(1627)									int newRange = (in_byteOffset + newByteLength);
HXDLIN(1627)									if ((newRange > bufferByteLength)) {
HXLINE(1627)										HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            									}
            								}
HXDLIN(1627)								_this3->buffer = buffer1;
HXDLIN(1627)								_this3->byteOffset = in_byteOffset;
HXDLIN(1627)								_this3->byteLength = newByteLength;
HXDLIN(1627)								_this3->length = ::Std_obj::_hx_int((( (Float)(newByteLength) ) / ( (Float)(_this3->bytesPerElement) )));
HXDLIN(1627)								this1 = _this3;
            							}
            							else {
HXLINE(1627)								HX_STACK_DO_THROW(HX_("Invalid constructor arguments for UInt8Array",6b,44,d5,85));
            							}
            						}
            					}
            				}
            			}
HXDLIN(1627)			buffer = ( ( ::Dynamic)(::lime::_internal::backend::native::NativeCFFI_obj::lime_image_load_file(hx::DynamicPtr(path),hx::DynamicPtr( ::lime::graphics::ImageBuffer_obj::__alloc( HX_CTX ,this1,null(),null(),null(),null())))) );
            		}
HXLINE(1673)		if (hx::IsNotNull( buffer )) {
HXLINE(1675)			this->_hx___fromImageBuffer(buffer);
HXLINE(1677)			if (hx::IsNotNull( onload )) {
HXLINE(1679)				onload(hx::ObjectPtr<OBJ_>(this));
            			}
HXLINE(1682)			return true;
            		}
HXLINE(1688)		return false;
            	}


HX_DEFINE_DYNAMIC_FUNC3(Image_obj,_hx___fromFile,return )

void Image_obj::_hx___fromImageBuffer( ::lime::graphics::ImageBuffer buffer){
            	HX_STACKFRAME(&_hx_pos_ef8f6e7e24e3b831_1692___fromImageBuffer)
HXLINE(1693)		this->buffer = buffer;
HXLINE(1695)		if (hx::IsNotNull( buffer )) {
HXLINE(1697)			if ((this->width == -1)) {
HXLINE(1699)				this->width = buffer->width;
            			}
HXLINE(1702)			if ((this->height == -1)) {
HXLINE(1704)				this->height = buffer->height;
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(Image_obj,_hx___fromImageBuffer,(void))

 ::lime::utils::ArrayBufferView Image_obj::get_data(){
            	HX_STACKFRAME(&_hx_pos_ef8f6e7e24e3b831_1744_get_data)
HXLINE(1745)		bool _hx_tmp;
HXDLIN(1745)		bool _hx_tmp1;
HXDLIN(1745)		if (hx::IsNull( this->buffer->data )) {
HXLINE(1745)			_hx_tmp1 = (this->buffer->width > 0);
            		}
            		else {
HXLINE(1745)			_hx_tmp1 = false;
            		}
HXDLIN(1745)		if (_hx_tmp1) {
HXLINE(1745)			_hx_tmp = (this->buffer->height > 0);
            		}
            		else {
HXLINE(1745)			_hx_tmp = false;
            		}
HXLINE(1755)		return this->buffer->data;
            	}


HX_DEFINE_DYNAMIC_FUNC0(Image_obj,get_data,return )

 ::lime::utils::ArrayBufferView Image_obj::set_data( ::lime::utils::ArrayBufferView value){
            	HX_STACKFRAME(&_hx_pos_ef8f6e7e24e3b831_1760_set_data)
HXDLIN(1760)		return (this->buffer->data = value);
            	}


HX_DEFINE_DYNAMIC_FUNC1(Image_obj,set_data,return )

int Image_obj::get_format(){
            	HX_STACKFRAME(&_hx_pos_ef8f6e7e24e3b831_1765_get_format)
HXDLIN(1765)		return this->buffer->format;
            	}


HX_DEFINE_DYNAMIC_FUNC0(Image_obj,get_format,return )

int Image_obj::set_format(int value){
            	HX_STACKFRAME(&_hx_pos_ef8f6e7e24e3b831_1769_set_format)
HXLINE(1770)		if ((this->buffer->format != value)) {
HXLINE(1772)			if ((this->type->_hx_getIndex() == 1)) {
HXLINE(1775)				::lime::_internal::graphics::ImageDataUtil_obj::setFormat(hx::ObjectPtr<OBJ_>(this),value);
            			}
            		}
HXLINE(1781)		return (this->buffer->format = value);
            	}


HX_DEFINE_DYNAMIC_FUNC1(Image_obj,set_format,return )

bool Image_obj::get_powerOfTwo(){
            	HX_STACKFRAME(&_hx_pos_ef8f6e7e24e3b831_1786_get_powerOfTwo)
HXDLIN(1786)		bool _hx_tmp;
HXDLIN(1786)		if ((this->buffer->width != 0)) {
HXDLIN(1786)			_hx_tmp = ((this->buffer->width & (~(this->buffer->width) + 1)) == this->buffer->width);
            		}
            		else {
HXDLIN(1786)			_hx_tmp = false;
            		}
HXDLIN(1786)		if (_hx_tmp) {
HXLINE(1788)			if ((this->buffer->height != 0)) {
HXLINE(1788)				return ((this->buffer->height & (~(this->buffer->height) + 1)) == this->buffer->height);
            			}
            			else {
HXLINE(1788)				return false;
            			}
            		}
            		else {
HXDLIN(1786)			return false;
            		}
HXDLIN(1786)		return false;
            	}


HX_DEFINE_DYNAMIC_FUNC0(Image_obj,get_powerOfTwo,return )

bool Image_obj::set_powerOfTwo(bool value){
            	HX_STACKFRAME(&_hx_pos_ef8f6e7e24e3b831_1792_set_powerOfTwo)
HXLINE(1793)		if ((value != this->get_powerOfTwo())) {
HXLINE(1795)			int newWidth = 1;
HXLINE(1796)			int newHeight = 1;
HXLINE(1798)			while((newWidth < this->buffer->width)){
HXLINE(1800)				newWidth = (newWidth << 1);
            			}
HXLINE(1803)			while((newHeight < this->buffer->height)){
HXLINE(1805)				newHeight = (newHeight << 1);
            			}
HXLINE(1808)			bool _hx_tmp;
HXDLIN(1808)			if ((newWidth == this->buffer->width)) {
HXLINE(1808)				_hx_tmp = (newHeight == this->buffer->height);
            			}
            			else {
HXLINE(1808)				_hx_tmp = false;
            			}
HXDLIN(1808)			if (_hx_tmp) {
HXLINE(1810)				return value;
            			}
HXLINE(1813)			switch((int)(this->type->_hx_getIndex())){
            				case (int)0: {
HXLINE(1819)					::lime::_internal::graphics::ImageDataUtil_obj::resizeBuffer(hx::ObjectPtr<OBJ_>(this),newWidth,newHeight);
            				}
            				break;
            				case (int)1: {
HXLINE(1822)					::lime::_internal::graphics::ImageDataUtil_obj::resizeBuffer(hx::ObjectPtr<OBJ_>(this),newWidth,newHeight);
            				}
            				break;
            				case (int)2: {
            				}
            				break;
            				default:{
            				}
            			}
            		}
HXLINE(1838)		return value;
            	}


HX_DEFINE_DYNAMIC_FUNC1(Image_obj,set_powerOfTwo,return )

bool Image_obj::get_premultiplied(){
            	HX_STACKFRAME(&_hx_pos_ef8f6e7e24e3b831_1843_get_premultiplied)
HXDLIN(1843)		return this->buffer->premultiplied;
            	}


HX_DEFINE_DYNAMIC_FUNC0(Image_obj,get_premultiplied,return )

bool Image_obj::set_premultiplied(bool value){
            	HX_STACKFRAME(&_hx_pos_ef8f6e7e24e3b831_1847_set_premultiplied)
HXLINE(1848)		bool _hx_tmp;
HXDLIN(1848)		if (value) {
HXLINE(1848)			_hx_tmp = !(this->buffer->premultiplied);
            		}
            		else {
HXLINE(1848)			_hx_tmp = false;
            		}
HXDLIN(1848)		if (_hx_tmp) {
HXLINE(1850)			switch((int)(this->type->_hx_getIndex())){
            				case (int)0: case (int)1: {
HXLINE(1857)					::lime::_internal::graphics::ImageDataUtil_obj::multiplyAlpha(hx::ObjectPtr<OBJ_>(this));
            				}
            				break;
            				default:{
            				}
            			}
            		}
            		else {
HXLINE(1863)			bool _hx_tmp1;
HXDLIN(1863)			if (!(value)) {
HXLINE(1863)				_hx_tmp1 = this->buffer->premultiplied;
            			}
            			else {
HXLINE(1863)				_hx_tmp1 = false;
            			}
HXDLIN(1863)			if (_hx_tmp1) {
HXLINE(1865)				if ((this->type->_hx_getIndex() == 1)) {
HXLINE(1872)					::lime::_internal::graphics::ImageDataUtil_obj::unmultiplyAlpha(hx::ObjectPtr<OBJ_>(this));
            				}
            			}
            		}
HXLINE(1879)		return value;
            	}


HX_DEFINE_DYNAMIC_FUNC1(Image_obj,set_premultiplied,return )

 ::lime::math::Rectangle Image_obj::get_rect(){
            	HX_GC_STACKFRAME(&_hx_pos_ef8f6e7e24e3b831_1884_get_rect)
HXDLIN(1884)		return  ::lime::math::Rectangle_obj::__alloc( HX_CTX ,0,0,this->width,this->height);
            	}


HX_DEFINE_DYNAMIC_FUNC0(Image_obj,get_rect,return )

 ::Dynamic Image_obj::get_src(){
            	HX_STACKFRAME(&_hx_pos_ef8f6e7e24e3b831_1896_get_src)
HXDLIN(1896)		return this->buffer->get_src();
            	}


HX_DEFINE_DYNAMIC_FUNC0(Image_obj,get_src,return )

 ::Dynamic Image_obj::set_src( ::Dynamic value){
            	HX_STACKFRAME(&_hx_pos_ef8f6e7e24e3b831_1901_set_src)
HXDLIN(1901)		return this->buffer->set_src(value);
            	}


HX_DEFINE_DYNAMIC_FUNC1(Image_obj,set_src,return )

bool Image_obj::get_transparent(){
            	HX_STACKFRAME(&_hx_pos_ef8f6e7e24e3b831_1905_get_transparent)
HXLINE(1906)		if (hx::IsNull( this->buffer )) {
HXLINE(1906)			return false;
            		}
HXLINE(1907)		return this->buffer->transparent;
            	}


HX_DEFINE_DYNAMIC_FUNC0(Image_obj,get_transparent,return )

bool Image_obj::set_transparent(bool value){
            	HX_STACKFRAME(&_hx_pos_ef8f6e7e24e3b831_1911_set_transparent)
HXLINE(1913)		if (hx::IsNull( this->buffer )) {
HXLINE(1913)			return false;
            		}
HXLINE(1914)		return (this->buffer->transparent = value);
            	}


HX_DEFINE_DYNAMIC_FUNC1(Image_obj,set_transparent,return )

 ::lime::graphics::Image Image_obj::fromBase64(::String base64,::String type){
            	HX_GC_STACKFRAME(&_hx_pos_ef8f6e7e24e3b831_613_fromBase64)
HXLINE( 614)		if (hx::IsNull( base64 )) {
HXLINE( 614)			return null();
            		}
HXLINE( 615)		 ::lime::graphics::Image image =  ::lime::graphics::Image_obj::__alloc( HX_CTX ,null(),null(),null(),null(),null(),null(),null());
HXLINE( 616)		image->_hx___fromBase64(base64,type,null());
HXLINE( 617)		return image;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Image_obj,fromBase64,return )

 ::lime::graphics::Image Image_obj::fromBitmapData( ::Dynamic bitmapData){
            	HX_STACKFRAME(&_hx_pos_ef8f6e7e24e3b831_627_fromBitmapData)
HXLINE( 628)		if (hx::IsNull( bitmapData )) {
HXLINE( 628)			return null();
            		}
HXLINE( 634)		return ( ( ::lime::graphics::Image)(bitmapData->__Field(HX_("image",5b,1f,69,bd),hx::paccDynamic)) );
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Image_obj,fromBitmapData,return )

 ::lime::graphics::Image Image_obj::fromBytes( ::haxe::io::Bytes bytes){
            	HX_GC_STACKFRAME(&_hx_pos_ef8f6e7e24e3b831_651_fromBytes)
HXLINE( 652)		if (hx::IsNull( bytes )) {
HXLINE( 652)			return null();
            		}
HXLINE( 653)		 ::lime::graphics::Image image =  ::lime::graphics::Image_obj::__alloc( HX_CTX ,null(),null(),null(),null(),null(),null(),null());
HXLINE( 654)		if (image->_hx___fromBytes(bytes,null())) {
HXLINE( 656)			return image;
            		}
            		else {
HXLINE( 660)			return null();
            		}
HXLINE( 654)		return null();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Image_obj,fromBytes,return )

 ::lime::graphics::Image Image_obj::fromCanvas( ::Dynamic canvas){
            	HX_GC_STACKFRAME(&_hx_pos_ef8f6e7e24e3b831_671_fromCanvas)
HXLINE( 672)		if (hx::IsNull( canvas )) {
HXLINE( 672)			return null();
            		}
HXLINE( 673)		 ::lime::graphics::ImageBuffer buffer =  ::lime::graphics::ImageBuffer_obj::__alloc( HX_CTX ,null(),canvas->__Field(HX_("width",06,b6,62,ca),hx::paccDynamic),canvas->__Field(HX_("height",e7,07,4c,02),hx::paccDynamic),null(),null());
HXLINE( 674)		buffer->set_src(canvas);
HXLINE( 675)		 ::lime::graphics::Image image =  ::lime::graphics::Image_obj::__alloc( HX_CTX ,buffer,null(),null(),null(),null(),null(),null());
HXLINE( 677)		image->type = ::lime::graphics::ImageType_obj::CANVAS_dyn();
HXLINE( 678)		return image;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Image_obj,fromCanvas,return )

 ::lime::graphics::Image Image_obj::fromFile(::String path){
            	HX_GC_STACKFRAME(&_hx_pos_ef8f6e7e24e3b831_694_fromFile)
HXLINE( 695)		if (hx::IsNull( path )) {
HXLINE( 695)			return null();
            		}
HXLINE( 696)		 ::lime::graphics::Image image =  ::lime::graphics::Image_obj::__alloc( HX_CTX ,null(),null(),null(),null(),null(),null(),null());
HXLINE( 697)		if (image->_hx___fromFile(path,null(),null())) {
HXLINE( 699)			return image;
            		}
            		else {
HXLINE( 703)			return null();
            		}
HXLINE( 697)		return null();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Image_obj,fromFile,return )

 ::lime::graphics::Image Image_obj::fromImageElement( ::Dynamic image){
            	HX_GC_STACKFRAME(&_hx_pos_ef8f6e7e24e3b831_714_fromImageElement)
HXLINE( 715)		if (hx::IsNull( image )) {
HXLINE( 715)			return null();
            		}
HXLINE( 716)		 ::lime::graphics::ImageBuffer buffer =  ::lime::graphics::ImageBuffer_obj::__alloc( HX_CTX ,null(),image->__Field(HX_("width",06,b6,62,ca),hx::paccDynamic),image->__Field(HX_("height",e7,07,4c,02),hx::paccDynamic),null(),null());
HXLINE( 717)		buffer->set_src(image);
HXLINE( 718)		 ::lime::graphics::Image _image =  ::lime::graphics::Image_obj::__alloc( HX_CTX ,buffer,null(),null(),null(),null(),null(),null());
HXLINE( 720)		_image->type = ::lime::graphics::ImageType_obj::CANVAS_dyn();
HXLINE( 721)		return _image;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Image_obj,fromImageElement,return )

 ::lime::app::Future Image_obj::loadFromBase64(::String base64,::String type){
            	HX_STACKFRAME(&_hx_pos_ef8f6e7e24e3b831_917_loadFromBase64)
HXLINE( 918)		bool _hx_tmp;
HXDLIN( 918)		if (hx::IsNotNull( base64 )) {
HXLINE( 918)			_hx_tmp = hx::IsNull( type );
            		}
            		else {
HXLINE( 918)			_hx_tmp = true;
            		}
HXDLIN( 918)		if (_hx_tmp) {
HXLINE( 918)			return ::lime::app::Future_obj::withValue(null());
            		}
HXLINE( 923)		if (hx::IsNotNull( base64 )) {
HXLINE( 925)			return ::lime::graphics::Image_obj::loadFromBytes(::lime::_internal::format::Base64_obj::decode(base64));
            		}
            		else {
HXLINE( 929)			return ::lime::app::Future_obj::withError(HX_("",00,00,00,00));
            		}
HXLINE( 923)		return null();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Image_obj,loadFromBase64,return )

 ::lime::app::Future Image_obj::loadFromBytes( ::haxe::io::Bytes bytes){
            		HX_BEGIN_LOCAL_FUNC_S1(hx::LocalFunc,_hx_Closure_0, ::haxe::io::Bytes,bytes) HXARGC(0)
            		 ::lime::graphics::Image _hx_run(){
            			HX_STACKFRAME(&_hx_pos_ef8f6e7e24e3b831_996_loadFromBytes)
HXLINE( 996)			return ::lime::graphics::Image_obj::fromBytes(bytes);
            		}
            		HX_END_LOCAL_FUNC0(return)

            	HX_GC_STACKFRAME(&_hx_pos_ef8f6e7e24e3b831_940_loadFromBytes)
HXLINE( 941)		if (hx::IsNull( bytes )) {
HXLINE( 941)			return ::lime::app::Future_obj::withValue(null());
            		}
HXLINE( 996)		return  ::lime::app::Future_obj::__alloc( HX_CTX , ::Dynamic(new _hx_Closure_0(bytes)),true);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Image_obj,loadFromBytes,return )

 ::lime::app::Future Image_obj::loadFromFile(::String path){
            		HX_BEGIN_LOCAL_FUNC_S0(hx::LocalFunc,_hx_Closure_0) HXARGC(1)
            		 ::lime::app::Future _hx_run( ::lime::graphics::Image image){
            			HX_GC_STACKFRAME(&_hx_pos_ef8f6e7e24e3b831_1055_loadFromFile)
HXLINE(1055)			if (hx::IsNotNull( image )) {
HXLINE(1057)				return ::lime::app::Future_obj::withValue(image);
            			}
            			else {
HXLINE(1061)				return ::lime::app::Future_obj::withError(HX_("",00,00,00,00));
            			}
HXLINE(1055)			return null();
            		}
            		HX_END_LOCAL_FUNC1(return)

            	HX_GC_STACKFRAME(&_hx_pos_ef8f6e7e24e3b831_1006_loadFromFile)
HXLINE(1007)		if (hx::IsNull( path )) {
HXLINE(1007)			return ::lime::app::Future_obj::withValue(null());
            		}
HXLINE(1052)		 ::lime::net::_HTTPRequest_lime_graphics_Image request =  ::lime::net::_HTTPRequest_lime_graphics_Image_obj::__alloc( HX_CTX ,null());
HXLINE(1053)		return request->load(path)->then( ::Dynamic(new _hx_Closure_0()));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Image_obj,loadFromFile,return )

bool Image_obj::_hx___isGIF( ::haxe::io::Bytes bytes){
            	HX_STACKFRAME(&_hx_pos_ef8f6e7e24e3b831_1710___isGIF)
HXLINE(1711)		bool _hx_tmp;
HXDLIN(1711)		if (hx::IsNotNull( bytes )) {
HXLINE(1711)			_hx_tmp = (bytes->length < 6);
            		}
            		else {
HXLINE(1711)			_hx_tmp = true;
            		}
HXDLIN(1711)		if (_hx_tmp) {
HXLINE(1711)			return false;
            		}
HXLINE(1713)		::String header = bytes->getString(0,6,null());
HXLINE(1714)		if ((header != HX_("GIF87a",1e,95,06,9a))) {
HXLINE(1714)			return (header == HX_("GIF89a",dc,96,06,9a));
            		}
            		else {
HXLINE(1714)			return true;
            		}
HXDLIN(1714)		return false;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Image_obj,_hx___isGIF,return )

bool Image_obj::_hx___isJPG( ::haxe::io::Bytes bytes){
            	HX_STACKFRAME(&_hx_pos_ef8f6e7e24e3b831_1718___isJPG)
HXLINE(1719)		bool _hx_tmp;
HXDLIN(1719)		if (hx::IsNotNull( bytes )) {
HXLINE(1719)			_hx_tmp = (bytes->length < 4);
            		}
            		else {
HXLINE(1719)			_hx_tmp = true;
            		}
HXDLIN(1719)		if (_hx_tmp) {
HXLINE(1719)			return false;
            		}
HXLINE(1721)		bool _hx_tmp1;
HXDLIN(1721)		bool _hx_tmp2;
HXDLIN(1721)		if ((bytes->b->__get(0) == 255)) {
HXLINE(1721)			_hx_tmp2 = (bytes->b->__get(1) == 216);
            		}
            		else {
HXLINE(1721)			_hx_tmp2 = false;
            		}
HXDLIN(1721)		if (_hx_tmp2) {
HXLINE(1721)			_hx_tmp1 = (bytes->b->__get((bytes->length - 2)) == 255);
            		}
            		else {
HXLINE(1721)			_hx_tmp1 = false;
            		}
HXDLIN(1721)		if (_hx_tmp1) {
HXLINE(1724)			return (bytes->b->__get((bytes->length - 1)) == 217);
            		}
            		else {
HXLINE(1721)			return false;
            		}
HXDLIN(1721)		return false;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Image_obj,_hx___isJPG,return )

bool Image_obj::_hx___isPNG( ::haxe::io::Bytes bytes){
            	HX_STACKFRAME(&_hx_pos_ef8f6e7e24e3b831_1728___isPNG)
HXLINE(1729)		bool _hx_tmp;
HXDLIN(1729)		if (hx::IsNotNull( bytes )) {
HXLINE(1729)			_hx_tmp = (bytes->length < 8);
            		}
            		else {
HXLINE(1729)			_hx_tmp = true;
            		}
HXDLIN(1729)		if (_hx_tmp) {
HXLINE(1729)			return false;
            		}
HXLINE(1731)		bool _hx_tmp1;
HXDLIN(1731)		bool _hx_tmp2;
HXDLIN(1731)		bool _hx_tmp3;
HXDLIN(1731)		bool _hx_tmp4;
HXDLIN(1731)		bool _hx_tmp5;
HXDLIN(1731)		bool _hx_tmp6;
HXDLIN(1731)		if ((bytes->b->__get(0) == 137)) {
HXLINE(1731)			_hx_tmp6 = (bytes->b->__get(1) == 80);
            		}
            		else {
HXLINE(1731)			_hx_tmp6 = false;
            		}
HXDLIN(1731)		if (_hx_tmp6) {
HXLINE(1731)			_hx_tmp5 = (bytes->b->__get(2) == 78);
            		}
            		else {
HXLINE(1731)			_hx_tmp5 = false;
            		}
HXDLIN(1731)		if (_hx_tmp5) {
HXLINE(1731)			_hx_tmp4 = (bytes->b->__get(3) == 71);
            		}
            		else {
HXLINE(1731)			_hx_tmp4 = false;
            		}
HXDLIN(1731)		if (_hx_tmp4) {
HXLINE(1731)			_hx_tmp3 = (bytes->b->__get(4) == 13);
            		}
            		else {
HXLINE(1731)			_hx_tmp3 = false;
            		}
HXDLIN(1731)		if (_hx_tmp3) {
HXLINE(1731)			_hx_tmp2 = (bytes->b->__get(5) == 10);
            		}
            		else {
HXLINE(1731)			_hx_tmp2 = false;
            		}
HXDLIN(1731)		if (_hx_tmp2) {
HXLINE(1731)			_hx_tmp1 = (bytes->b->__get(6) == 26);
            		}
            		else {
HXLINE(1731)			_hx_tmp1 = false;
            		}
HXDLIN(1731)		if (_hx_tmp1) {
HXLINE(1732)			return (bytes->b->__get(7) == 10);
            		}
            		else {
HXLINE(1731)			return false;
            		}
HXDLIN(1731)		return false;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Image_obj,_hx___isPNG,return )

bool Image_obj::_hx___isWebP( ::haxe::io::Bytes bytes){
            	HX_STACKFRAME(&_hx_pos_ef8f6e7e24e3b831_1736___isWebP)
HXLINE(1737)		bool _hx_tmp;
HXDLIN(1737)		if (hx::IsNotNull( bytes )) {
HXLINE(1737)			_hx_tmp = (bytes->length < 16);
            		}
            		else {
HXLINE(1737)			_hx_tmp = true;
            		}
HXDLIN(1737)		if (_hx_tmp) {
HXLINE(1737)			return false;
            		}
HXLINE(1739)		if ((bytes->getString(0,4,null()) == HX_("RIFF",b7,20,6b,36))) {
HXLINE(1739)			return (bytes->getString(8,4,null()) == HX_("WEBP",5c,25,b6,39));
            		}
            		else {
HXLINE(1739)			return false;
            		}
HXDLIN(1739)		return false;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Image_obj,_hx___isWebP,return )


hx::ObjectPtr< Image_obj > Image_obj::__new( ::lime::graphics::ImageBuffer buffer,hx::Null< int >  __o_offsetX,hx::Null< int >  __o_offsetY,hx::Null< int >  __o_width,hx::Null< int >  __o_height, ::Dynamic color, ::lime::graphics::ImageType type) {
	hx::ObjectPtr< Image_obj > __this = new Image_obj();
	__this->__construct(buffer,__o_offsetX,__o_offsetY,__o_width,__o_height,color,type);
	return __this;
}

hx::ObjectPtr< Image_obj > Image_obj::__alloc(hx::Ctx *_hx_ctx, ::lime::graphics::ImageBuffer buffer,hx::Null< int >  __o_offsetX,hx::Null< int >  __o_offsetY,hx::Null< int >  __o_width,hx::Null< int >  __o_height, ::Dynamic color, ::lime::graphics::ImageType type) {
	Image_obj *__this = (Image_obj*)(hx::Ctx::alloc(_hx_ctx, sizeof(Image_obj), true, "lime.graphics.Image"));
	*(void **)__this = Image_obj::_hx_vtable;
	__this->__construct(buffer,__o_offsetX,__o_offsetY,__o_width,__o_height,color,type);
	return __this;
}

Image_obj::Image_obj()
{
}

void Image_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(Image);
	HX_MARK_MEMBER_NAME(buffer,"buffer");
	HX_MARK_MEMBER_NAME(dirty,"dirty");
	HX_MARK_MEMBER_NAME(height,"height");
	HX_MARK_MEMBER_NAME(offsetX,"offsetX");
	HX_MARK_MEMBER_NAME(offsetY,"offsetY");
	HX_MARK_MEMBER_NAME(rect,"rect");
	HX_MARK_MEMBER_NAME(type,"type");
	HX_MARK_MEMBER_NAME(version,"version");
	HX_MARK_MEMBER_NAME(width,"width");
	HX_MARK_MEMBER_NAME(x,"x");
	HX_MARK_MEMBER_NAME(y,"y");
	HX_MARK_END_CLASS();
}

void Image_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(buffer,"buffer");
	HX_VISIT_MEMBER_NAME(dirty,"dirty");
	HX_VISIT_MEMBER_NAME(height,"height");
	HX_VISIT_MEMBER_NAME(offsetX,"offsetX");
	HX_VISIT_MEMBER_NAME(offsetY,"offsetY");
	HX_VISIT_MEMBER_NAME(rect,"rect");
	HX_VISIT_MEMBER_NAME(type,"type");
	HX_VISIT_MEMBER_NAME(version,"version");
	HX_VISIT_MEMBER_NAME(width,"width");
	HX_VISIT_MEMBER_NAME(x,"x");
	HX_VISIT_MEMBER_NAME(y,"y");
}

hx::Val Image_obj::__Field(const ::String &inName,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 1:
		if (HX_FIELD_EQ(inName,"x") ) { return hx::Val( x ); }
		if (HX_FIELD_EQ(inName,"y") ) { return hx::Val( y ); }
		break;
	case 3:
		if (HX_FIELD_EQ(inName,"src") ) { if (inCallProp == hx::paccAlways) return hx::Val( get_src() ); }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"data") ) { if (inCallProp == hx::paccAlways) return hx::Val( get_data() ); }
		if (HX_FIELD_EQ(inName,"rect") ) { return hx::Val( inCallProp == hx::paccAlways ? get_rect() : rect ); }
		if (HX_FIELD_EQ(inName,"type") ) { return hx::Val( type ); }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"dirty") ) { return hx::Val( dirty ); }
		if (HX_FIELD_EQ(inName,"width") ) { return hx::Val( width ); }
		if (HX_FIELD_EQ(inName,"clone") ) { return hx::Val( clone_dyn() ); }
		if (HX_FIELD_EQ(inName,"merge") ) { return hx::Val( merge_dyn() ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"buffer") ) { return hx::Val( buffer ); }
		if (HX_FIELD_EQ(inName,"format") ) { if (inCallProp == hx::paccAlways) return hx::Val( get_format() ); }
		if (HX_FIELD_EQ(inName,"height") ) { return hx::Val( height ); }
		if (HX_FIELD_EQ(inName,"encode") ) { return hx::Val( encode_dyn() ); }
		if (HX_FIELD_EQ(inName,"resize") ) { return hx::Val( resize_dyn() ); }
		if (HX_FIELD_EQ(inName,"scroll") ) { return hx::Val( scroll_dyn() ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"offsetX") ) { return hx::Val( offsetX ); }
		if (HX_FIELD_EQ(inName,"offsetY") ) { return hx::Val( offsetY ); }
		if (HX_FIELD_EQ(inName,"version") ) { return hx::Val( version ); }
		if (HX_FIELD_EQ(inName,"get_src") ) { return hx::Val( get_src_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_src") ) { return hx::Val( set_src_dyn() ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"fillRect") ) { return hx::Val( fillRect_dyn() ); }
		if (HX_FIELD_EQ(inName,"getPixel") ) { return hx::Val( getPixel_dyn() ); }
		if (HX_FIELD_EQ(inName,"setPixel") ) { return hx::Val( setPixel_dyn() ); }
		if (HX_FIELD_EQ(inName,"get_data") ) { return hx::Val( get_data_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_data") ) { return hx::Val( set_data_dyn() ); }
		if (HX_FIELD_EQ(inName,"get_rect") ) { return hx::Val( get_rect_dyn() ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"floodFill") ) { return hx::Val( floodFill_dyn() ); }
		if (HX_FIELD_EQ(inName,"getPixels") ) { return hx::Val( getPixels_dyn() ); }
		if (HX_FIELD_EQ(inName,"setPixels") ) { return hx::Val( setPixels_dyn() ); }
		if (HX_FIELD_EQ(inName,"threshold") ) { return hx::Val( threshold_dyn() ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"powerOfTwo") ) { if (inCallProp == hx::paccAlways) return hx::Val( get_powerOfTwo() ); }
		if (HX_FIELD_EQ(inName,"copyPixels") ) { return hx::Val( copyPixels_dyn() ); }
		if (HX_FIELD_EQ(inName,"getPixel32") ) { return hx::Val( getPixel32_dyn() ); }
		if (HX_FIELD_EQ(inName,"setPixel32") ) { return hx::Val( setPixel32_dyn() ); }
		if (HX_FIELD_EQ(inName,"__clipRect") ) { return hx::Val( _hx___clipRect_dyn() ); }
		if (HX_FIELD_EQ(inName,"__fromFile") ) { return hx::Val( _hx___fromFile_dyn() ); }
		if (HX_FIELD_EQ(inName,"get_format") ) { return hx::Val( get_format_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_format") ) { return hx::Val( set_format_dyn() ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"transparent") ) { if (inCallProp == hx::paccAlways) return hx::Val( get_transparent() ); }
		if (HX_FIELD_EQ(inName,"copyChannel") ) { return hx::Val( copyChannel_dyn() ); }
		if (HX_FIELD_EQ(inName,"__fromBytes") ) { return hx::Val( _hx___fromBytes_dyn() ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"__fromBase64") ) { return hx::Val( _hx___fromBase64_dyn() ); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"premultiplied") ) { if (inCallProp == hx::paccAlways) return hx::Val( get_premultiplied() ); }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"colorTransform") ) { return hx::Val( colorTransform_dyn() ); }
		if (HX_FIELD_EQ(inName,"get_powerOfTwo") ) { return hx::Val( get_powerOfTwo_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_powerOfTwo") ) { return hx::Val( set_powerOfTwo_dyn() ); }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"get_transparent") ) { return hx::Val( get_transparent_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_transparent") ) { return hx::Val( set_transparent_dyn() ); }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"__fromImageBuffer") ) { return hx::Val( _hx___fromImageBuffer_dyn() ); }
		if (HX_FIELD_EQ(inName,"get_premultiplied") ) { return hx::Val( get_premultiplied_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_premultiplied") ) { return hx::Val( set_premultiplied_dyn() ); }
		break;
	case 18:
		if (HX_FIELD_EQ(inName,"getColorBoundsRect") ) { return hx::Val( getColorBoundsRect_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

bool Image_obj::__GetStatic(const ::String &inName, Dynamic &outValue, hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 7:
		if (HX_FIELD_EQ(inName,"__isGIF") ) { outValue = _hx___isGIF_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"__isJPG") ) { outValue = _hx___isJPG_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"__isPNG") ) { outValue = _hx___isPNG_dyn(); return true; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"fromFile") ) { outValue = fromFile_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"__isWebP") ) { outValue = _hx___isWebP_dyn(); return true; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"fromBytes") ) { outValue = fromBytes_dyn(); return true; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"fromBase64") ) { outValue = fromBase64_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"fromCanvas") ) { outValue = fromCanvas_dyn(); return true; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"loadFromFile") ) { outValue = loadFromFile_dyn(); return true; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"loadFromBytes") ) { outValue = loadFromBytes_dyn(); return true; }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"fromBitmapData") ) { outValue = fromBitmapData_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"loadFromBase64") ) { outValue = loadFromBase64_dyn(); return true; }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"fromImageElement") ) { outValue = fromImageElement_dyn(); return true; }
	}
	return false;
}

hx::Val Image_obj::__SetField(const ::String &inName,const hx::Val &inValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 1:
		if (HX_FIELD_EQ(inName,"x") ) { x=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"y") ) { y=inValue.Cast< Float >(); return inValue; }
		break;
	case 3:
		if (HX_FIELD_EQ(inName,"src") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_src(inValue.Cast<  ::Dynamic >()) ); }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"data") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_data(inValue.Cast<  ::lime::utils::ArrayBufferView >()) ); }
		if (HX_FIELD_EQ(inName,"rect") ) { rect=inValue.Cast<  ::lime::math::Rectangle >(); return inValue; }
		if (HX_FIELD_EQ(inName,"type") ) { type=inValue.Cast<  ::lime::graphics::ImageType >(); return inValue; }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"dirty") ) { dirty=inValue.Cast< bool >(); return inValue; }
		if (HX_FIELD_EQ(inName,"width") ) { width=inValue.Cast< int >(); return inValue; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"buffer") ) { buffer=inValue.Cast<  ::lime::graphics::ImageBuffer >(); return inValue; }
		if (HX_FIELD_EQ(inName,"format") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_format(inValue.Cast< int >()) ); }
		if (HX_FIELD_EQ(inName,"height") ) { height=inValue.Cast< int >(); return inValue; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"offsetX") ) { offsetX=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"offsetY") ) { offsetY=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"version") ) { version=inValue.Cast< int >(); return inValue; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"powerOfTwo") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_powerOfTwo(inValue.Cast< bool >()) ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"transparent") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_transparent(inValue.Cast< bool >()) ); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"premultiplied") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_premultiplied(inValue.Cast< bool >()) ); }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void Image_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("buffer",00,bd,94,d0));
	outFields->push(HX_("data",2a,56,63,42));
	outFields->push(HX_("dirty",12,50,d0,d9));
	outFields->push(HX_("format",37,8f,8e,fd));
	outFields->push(HX_("height",e7,07,4c,02));
	outFields->push(HX_("offsetX",65,09,65,d7));
	outFields->push(HX_("offsetY",66,09,65,d7));
	outFields->push(HX_("powerOfTwo",70,be,ae,ea));
	outFields->push(HX_("premultiplied",56,f1,4e,a4));
	outFields->push(HX_("rect",24,4d,a7,4b));
	outFields->push(HX_("src",e4,a6,57,00));
	outFields->push(HX_("transparent",52,2b,ba,22));
	outFields->push(HX_("type",ba,f2,08,4d));
	outFields->push(HX_("version",18,e7,f1,7c));
	outFields->push(HX_("width",06,b6,62,ca));
	outFields->push(HX_("x",78,00,00,00));
	outFields->push(HX_("y",79,00,00,00));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static hx::StorageInfo Image_obj_sMemberStorageInfo[] = {
	{hx::fsObject /*  ::lime::graphics::ImageBuffer */ ,(int)offsetof(Image_obj,buffer),HX_("buffer",00,bd,94,d0)},
	{hx::fsBool,(int)offsetof(Image_obj,dirty),HX_("dirty",12,50,d0,d9)},
	{hx::fsInt,(int)offsetof(Image_obj,height),HX_("height",e7,07,4c,02)},
	{hx::fsInt,(int)offsetof(Image_obj,offsetX),HX_("offsetX",65,09,65,d7)},
	{hx::fsInt,(int)offsetof(Image_obj,offsetY),HX_("offsetY",66,09,65,d7)},
	{hx::fsObject /*  ::lime::math::Rectangle */ ,(int)offsetof(Image_obj,rect),HX_("rect",24,4d,a7,4b)},
	{hx::fsObject /*  ::lime::graphics::ImageType */ ,(int)offsetof(Image_obj,type),HX_("type",ba,f2,08,4d)},
	{hx::fsInt,(int)offsetof(Image_obj,version),HX_("version",18,e7,f1,7c)},
	{hx::fsInt,(int)offsetof(Image_obj,width),HX_("width",06,b6,62,ca)},
	{hx::fsFloat,(int)offsetof(Image_obj,x),HX_("x",78,00,00,00)},
	{hx::fsFloat,(int)offsetof(Image_obj,y),HX_("y",79,00,00,00)},
	{ hx::fsUnknown, 0, null()}
};
static hx::StaticInfo *Image_obj_sStaticStorageInfo = 0;
#endif

static ::String Image_obj_sMemberFields[] = {
	HX_("buffer",00,bd,94,d0),
	HX_("dirty",12,50,d0,d9),
	HX_("height",e7,07,4c,02),
	HX_("offsetX",65,09,65,d7),
	HX_("offsetY",66,09,65,d7),
	HX_("rect",24,4d,a7,4b),
	HX_("type",ba,f2,08,4d),
	HX_("version",18,e7,f1,7c),
	HX_("width",06,b6,62,ca),
	HX_("x",78,00,00,00),
	HX_("y",79,00,00,00),
	HX_("clone",5d,13,63,48),
	HX_("colorTransform",89,d7,3f,ad),
	HX_("copyChannel",8e,7d,e6,22),
	HX_("copyPixels",c2,54,6e,42),
	HX_("encode",16,f2,e3,f9),
	HX_("fillRect",47,45,b9,6c),
	HX_("floodFill",61,83,8a,59),
	HX_("getColorBoundsRect",86,ad,e8,80),
	HX_("getPixel",10,d6,7a,22),
	HX_("getPixel32",af,a6,68,d7),
	HX_("getPixels",63,78,00,09),
	HX_("merge",b8,a2,c6,05),
	HX_("resize",f4,59,7b,08),
	HX_("scroll",0d,d8,64,47),
	HX_("setPixel",84,2f,d8,d0),
	HX_("setPixel32",23,45,e6,da),
	HX_("setPixels",6f,64,51,ec),
	HX_("threshold",ab,c3,a3,34),
	HX_("__clipRect",34,03,a3,fb),
	HX_("__fromBase64",b9,7d,ff,d0),
	HX_("__fromBytes",81,3b,4d,a0),
	HX_("__fromFile",26,10,c0,44),
	HX_("__fromImageBuffer",51,6e,ca,ca),
	HX_("get_data",b3,11,1e,c2),
	HX_("set_data",27,6b,7b,70),
	HX_("get_format",00,ff,15,ee),
	HX_("set_format",74,9d,93,f1),
	HX_("get_powerOfTwo",b9,46,a4,60),
	HX_("set_powerOfTwo",2d,2f,c4,80),
	HX_("get_premultiplied",ad,fc,be,aa),
	HX_("set_premultiplied",b9,d4,2c,ce),
	HX_("get_rect",ad,08,62,cb),
	HX_("get_src",7b,6f,cc,26),
	HX_("set_src",87,00,ce,19),
	HX_("get_transparent",e9,e2,9b,e3),
	HX_("set_transparent",f5,5f,67,df),
	::String(null()) };

hx::Class Image_obj::__mClass;

static ::String Image_obj_sStaticFields[] = {
	HX_("fromBase64",99,02,6c,98),
	HX_("fromBitmapData",c3,07,ed,2b),
	HX_("fromBytes",a1,f2,20,72),
	HX_("fromCanvas",e2,59,86,fb),
	HX_("fromFile",06,9d,87,a1),
	HX_("fromImageElement",2b,91,89,8f),
	HX_("loadFromBase64",5f,0c,1d,2f),
	HX_("loadFromBytes",9b,c3,86,f4),
	HX_("loadFromFile",4c,89,f0,5a),
	HX_("__isGIF",1a,eb,aa,2b),
	HX_("__isJPG",f7,37,ad,2b),
	HX_("__isPNG",bf,c3,b1,2b),
	HX_("__isWebP",66,8d,8b,14),
	::String(null())
};

void Image_obj::__register()
{
	Image_obj _hx_dummy;
	Image_obj::_hx_vtable = *(void **)&_hx_dummy;
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_("lime.graphics.Image",91,28,c1,9c);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &Image_obj::__GetStatic;
	__mClass->mSetStaticField = &hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = hx::Class_obj::dupFunctions(Image_obj_sStaticFields);
	__mClass->mMembers = hx::Class_obj::dupFunctions(Image_obj_sMemberFields);
	__mClass->mCanCast = hx::TCanCast< Image_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Image_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Image_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace lime
} // end namespace graphics
